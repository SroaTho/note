# 优先级

| 优先级 | 运算符   | 描述                               | 结合性   |
| ------ | -------- | ---------------------------------- | -------- |
| 1      | `::`     | 作用域解析运算符（C++）            | 从左到右 |
|        | `()`     | 调节优先级的括号操作符             | 从左到右 |
|        | `[]`     | 数组下标访问操作符                 | 从左到右 |
|        | `.`      | 通过对象本身访问成员的操作符       | 从左到右 |
|        | `->`     | 通过指向对象的指针访问成员的操作符 | 从左到右 |
|        | `++`     | 后置自增操作符                     | 从左到右 |
|        | `--`     | 后置自减操作符                     | 从左到右 |
| 2      | `++`     | 前置自增操作符                     | 从右到左 |
|        | `--`     | 前置自减操作符                     | 从右到左 |
|        | `+`      | 一元取正操作符                     | 从右到左 |
|        | `-`      | 一元取负操作符                     | 从右到左 |
|        | `!`      | 逻辑取反操作符                     | 从右到左 |
|        | `~`      | 按位取反(按位取补)                 | 从右到左 |
|        | `*`      | 解引用操作符                       | 从右到左 |
|        | `&`      | 取地址操作符                       | 从右到左 |
|        | `(type)` | 类型转换操作符                     | 从右到左 |
|        | `sizeof` | 返回对象占用的字节数操作符         | 从右到左 |
|        | `new`    | 动态内存分配（C++）                | 从右到左 |
|        | `delete` | 动态内存释放（C++）                | 从右到左 |
| 3      | `*`      | 乘法操作符                         | 从左到右 |
|        | `/`      | 除法操作符                         | 从左到右 |
|        | `%`      | 取余数操作符                       | 从左到右 |
| 4      | `+`      | 加法操作符                         | 从左到右 |
|        | `-`      | 减法操作符                         | 从左到右 |
| 5      | `<<`     | 按位左移操作符                     | 从左到右 |
|        | `>>`     | 按位右移操作符                     | 从左到右 |
| 6      | `<`      | 小于比较操作符                     | 从左到右 |
|        | `<=`     | 小于或等于比较操作符               | 从左到右 |
|        | `>`      | 大于比较操作符                     | 从左到右 |
|        | `>=`     | 大于或等于比较操作符               | 从左到右 |
| 7      | `==`     | 等于比较操作符                     | 从左到右 |
|        | `!=`     | 不等于比较操作符                   | 从左到右 |
| 8      | `&`      | 按位与操作符                       | 从左到右 |
| 9      | `^`      | 按位异或操作符                     | 从左到右 |
| 10     | `|`      | 按位或操作符                       | 从左到右 |
| 11     | `&&`     | 逻辑与操作符                       | 从左到右 |
| 12     | `||`     | 逻辑或操作符                       | 从左到右 |
| 13     | `?:`     | 三元条件操作符                     | 从右到左 |
| 14     | `=`      | 赋值操作符                         | 从右到左 |
|        | `+=`     | 复合赋值操作符(加法)               | 从右到左 |
|        | `-=`     | 复合赋值操作符(减法)               | 从右到左 |
|        | `*=`     | 复合赋值操作符(乘法)               | 从右到左 |
|        | `/=`     | 复合赋值操作符(除法)               | 从右到左 |
|        | `%=`     | 复合赋值操作符(取余)               | 从右到左 |
|        | `&=`     | 复合赋值操作符(按位与)             | 从右到左 |
|        | `^=`     | 复合赋值操作符(按位异或)           | 从右到左 |
|        | `|=`     | 复合赋值操作符(按位或)             | 从右到左 |
|        | `<<=`    | 复合赋值操作符(按位左移)           | 从右到左 |
|        | `>>=`    | 复合赋值操作符(按位右移)           | 从右到左 |
| 15     | `,`      | 逗号操作符                         | 从左到右 |



# 赋值语句

## 1. 普通赋值

赋值语句将值赋给存储单元。

`Carrots =25;`

符号"="叫做赋值运算符。C++(和C)有一项不寻常的特性——可以连续使用赋值运算符。

```c++
int steinway;
int baldwin;
int yamaha;
yamaha = baldwin = steinway = 88;
```



在定义函数时可以为其赋值，这个过程称之为初始化。

`int yamaha = 100;`



## 2. 组合赋值运算符

```c++
i = i + by;
```

++提供了一种可以同时进行加法和赋值操作的运算符，使得这种任务可以更简洁地完成：

```c++
i += by;
```



`+=`运算符将两个操作数相加，并将结果赋给左边的操作数，左边的操作数必须是可以被赋值的。

```cpp
i *= by + 1;
i = i * (by + 1);		//等价于 i = i * (by + 1);
i = i * by + 1;			//而不是 i = i * by + 1; 或 i = (i * by) + 1;
```



| 操作符 | 作用              |
| :----- | :---------------- |
| `+=`   | 将 `L+R` 赋给 `L` |
| `-=`   | 将 `L-R` 赋给 `L` |
| `*=`   | 将 `L*R` 赋给 `L` |
| `/=`   | 将 `L/R` 赋给 `L` |
| `%=`   | 将 `L%R` 赋给 `L` |



# 基类运算符



## 1. 求模运算符

用于计算两个整数相除后的余数，只能用于整数。

```c++
int a = 10;
int b = 3;
int result = a % b;  // 结果为 1，因为 10 除以 3 的余数为 1
```



## 2. sizeof运算符

sizeof 是一个编译时运算符，用于确定其操作数的大小，**可对类型名或变量名使用** sizeof运算符。

对**类型名**(如imnt)使用sizeof运算符时，**应将名称放在括号**中;

但对**变量名**(如nshort)使用该运算符，**括号是可选**的:

```c++
cout << "int is" << sizeof(int) << "bytes.\n";
cout <<"short is" <<sizeof nshort << "bytes.\n";
```





# 逻辑运算符



## 2. 逻辑 OR 运算符 (`||`)

逻辑 OR 运算符 `||` 用于连接两个条件表达式。如果至少有一个条件表达式的值为 `true`，则整个表达式的值为 `true`。只有当两个条件表达式的值都为 `false` 时，整个表达式的值才为 `false`。

例如：

```c++
if (x > 10 || y > 10) {
    // 如果 x 大于 10 或者 y 大于 10，则执行这里的代码
}
```



C++规定，`||`运算符是个顺序点(sequence point)。也是说，先修改左侧的值，并且在右侧被判定之前产生所有的副作用，再对右侧的值进行判定(C++11的说法是，运算符左边的子表达式先于右边的子表达式)。

例如，请看下面的表达式:

```
i++ < 6 || i == j
```

假设i原来的值为10，则在对i和j进行比较时，i的值将为11。

另外，如果左侧的表达式为true，则C++将不会去判定右侧的表达式，因为只要一个表达式为 true,则整个逻辑表达式为 true。



## 2. 逻辑 AND 运算符 (`&&`)

逻辑 AND 运算符 `&&` 也用于连接两个条件表达式。只有当两个条件表达式的值都为 `true` 时，整个表达式的值才为 `true`。如果至少有一个条件表达式的值为 `false`，则整个表达式的值为 `false`。

例如：

```c++
if (x > 10 && y > 10) {
    // 如果 x 大于 10 并且 y 大于 10，则执行这里的代码
}
```



你可以使用 `&&` 运算符来设置取值范围。例如：

```c++
if (x >= 10 && x <= 20) {
    // 如果 x 的值在 10 到 20 之间，则执行这里的代码
}
```



&&运算符是顺序点，因此将首先判定左侧，并且在右侧被判定之前产生所有的副作用。

如果左侧为false，则整个逻辑表达式必定为 false，在这种情况下，C++将不会再对右侧进行判定。



## 3. 逻辑 NOT 运算符 (`!`)

逻辑 NOT 运算符 `!` 用于对一个条件表达式进行取反操作。如果条件表达式的值为 `true`，则 `!` 运算符会使其变为 `false`；如果条件表达式的值为 `false`，则 `!` 运算符会使其变为 `true`。

例如：

```c++
if (!done) {
    // 如果 done 的值为 false，则执行这里的代码
}
```





## 4. 其他表示方式

并不是所有的键盘都提供了用作逻辑运算符的符号，因此C++标准提供了另一种表示方式，

标识符 and、or 和 not都是 C++保留字，这意味着不能将它们用作变量名等。

它们不是关键字，因为它们都是已有语言特性的另一种表示方式。

它们并不是C语言中的保留字，但C语言程序可以将它们用作运算符，只要在程序中包含了头文件iso646.h。

C++不要求使用头文件。

| 运算符 | 另一种表示方式 |
| :----- | :------------- |
| `&&`   | `and`          |
| `||`   | `or`           |
| `!`    | `not`          |





# 递增和递减

## 1. 递增递减运算符

在C++中，`++`是递增运算符，`--`是递减运算符。

两种形式：

- 前缀形式（如`++x`）前缀形式先递增或递减变量的值，然后返回新值；
- 后缀形式（如`x++`）后缀形式先返回变量的当前值，然后再递增或递减变量的值。

```cpp
int x = 5;
int y = ++x; // 先递增x，然后将新值赋给y。现在，x和y都是6。
int z = 5;
int w = z++; // 先将z的当前值赋给w，然后再递增z。现在，z是6，w是5。
```



在同一条语句中对同一个值递增或递减多次可能会导致不确定的行为，因为“使用后修改”和“修改后使用”的规则可能会变得模糊不清。

例如，下面这条语句在不同的系统上可能会产生不同的结果：

```cpp
x = 2 * x++ * (3 - ++x); // 不建议这样做
```

对于这种语句，C++没有定义正确的行为。因此，我们应该避免编写这样的代码。



## 2. 副作用和顺序点

- **副作用**：在C++中，副作用指的是在计算表达式时对某些东西（如存储在变量中的值）进行了修改。
- **顺序点**：顺序点是程序执行过程中的一个点，在这里，进入下一步之前将确保对所有的副作用都进行了评估。在C++中，语句中的分号就是一个顺序点，这意味着程序处理下一条语句之前，赋值运算符、递增运算符和递减运算符执行的所有修改都必须完成。
- **完整表达式**：完整表达式是这样一个表达式：不是另一个更大表达式的子表达式。完整表达式的例子有：表达式语句中的表达式部分以及用作`while`循环中检测条件的表达式。
- **递增运算符**：在C++中，递增运算符有两种形式：前缀形式（`++i`）和后缀形式（`i++`）。前缀形式先递增变量的值，然后返回新值；后缀形式先返回变量的当前值，然后再递增变量的值。

以下是一些代码示例：

```cpp
int guests = 0;
while(guests++ < 10)
    cout << guests << endl;
```

在这个例子中，`guests++ < 10`是一个完整表达式，因为它是一个`while`循环的测试条件，因此该表达式的末尾是一个顺序点。

所以，C++确保副作用（将`guests`加1）在程序进入`cout`之前完成。



```cpp
int x = 0;
int y = (4 + x++) + (6 + x++);
```

在这个例子中，整条赋值语句是一个完整表达式，而分号标示了顺序点，因此C++只保证程序执行到下一条语句之前，`x`的值将被递增两次。C++没有规定是在计算每个子表达式之后将`x`的值递增，还是在整个表达式计算完毕后才将`x`的值递增。



在C++11及以后的版本中，不再使用术语“顺序点”，而是使用了术语“顺序”，它表示有些事件在其他事件前发生。这种描述方法并非要改变规则，而旨在更清晰地描述多线程编程。



## 3. 前缀和后缀的效率

如果递增或递减表达式的值没有被使用，那么使用前缀格式和后缀格式没有任何区别。

例如，下面两条语句的作用是相同的：

```cpp
x++;
++x;
```



同样，下面两条语句的作用也是相同的：

```cpp
for(n = lim; n > 0; --n)
for(n = lim; n > 0; n--)
```

在这些例子中，递增或递减表达式的值未被使用，因此只存在副作用。使用这些运算符的表达式为完整表达式，因此将`x`加1和`n`减1的副作用将在程序进入下一步之前完成，前缀格式和后缀格式的最终效果相同。



虽然选择使用前缀格式还是后缀格式对程序的行为没有影响，但执行速度可能有细微的差别。

对于内置类型和当代的编译器而言，这看似不是什么问题。

C++允许你针对类定义这些运算符，在这种情况下，前缀版本的效率比后缀版本高。

这是因为后缀版本首先复制一个副本，将其加1然后将复制的副本返回，而前缀版本则直接将值加1，然后返回结果。

因此，对于用户定义的类型，如果有用户定义的递增和递减运算符，则前缀格式的效率更高。

 

## 4. 用于指针

在C++中，`++`是递增运算符，`--`是递减运算符。这两个运算符都可以用于指针和基本变量。

当递增运算符用于指针时，将把指针的值增加其指向的数据类型占用的字节数。这种规则同样适用于对指针递减。

```cpp
double arr[5] = {21.1, 32.8, 23.4, 45.2, 37.4};
double *pt = arr; // pt指向arr[0]，即21.1
++pt; // pt现在指向arr[1]，即32.8
```



结合使用解引用运算符（`*`）和递增/递减运算符来修改指针指向的值。

当`*`和`++`同时用于指针时，将什么解引用，将什么递增，取决于运算符的位置和优先级。

```cpp
double x = *++pt; // 先递增指针，然后取值；即arr[2]，或23.4
++*pt; // 先取得pt指向的值，然后将这个值加1；即，将23.4改为24.4。在这种情况下，pt仍然指向arr[2]。
(*pt)++; // 首先对指针解引用，得到24.4。然后，运算符++将这个值递增到25.4，pt仍然指向arr[2]。
double X = *pt++; // 先解引用原始位置，然后递增指针。在这种情况下，*pt++的值为arr[2]，即25.4，但该语句执行完毕后，pt的值将为arr[3]的地址。
```





