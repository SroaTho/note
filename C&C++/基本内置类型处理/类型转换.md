# 类型转换

C++自动执行很多类型转换：

1. 将一种算术类型的值赋给另一种算术类型的变量时，C++将对值进行转换;

2. 表达式中包含不同的类型时，C++将对值进行转换;

3. 将参数传递给函数时，C++将对值进行转换。







## 1. 表达式中的转换

计算表达式时，C++会将`bool`、`char`、`unsigned char`、`signed char`和`short`值转换为`int`。

`true`被转换为1，`false`被转换为0。

如果`short`比`int`短，则`unsigned short`类型将被转换为`int`；如果两种类型的长度相同，则`unsigned short`类型将被转换为`unsigned int`。

此外，`wchar_t`会被提升为足够宽以存储其取值范围的类型，如`int`、`unsigned int`、`long`或`unsigned long`。



运算涉及两种类型时，较小的类型将被转换为较大的类型。例如，当`int`和`float`相加时，`int`会被转换为`float`。编译器通过查阅校验表来确定在算术表达式中执行的转换。

以下是C++11版本的校验表：

1. 如果有一个操作数的类型是`long double`，则将另一个操作数转换为`long double`。
2. 否则，如果有一个操作数的类型是`double`，则将另一个操作数转换为`double`。
3. 否则，如果有一个操作数的类型是`float`，则将另一个操作数转换为`float`。
4. 否则，说明操作数都是整型，因此执行整型提升。
5. 在这种情况下，如果两个操作数都是有符号或无符号的，且其中一个操作数的级别比另一个低，则转换为级别高的类型。
6. 如果一个操作数为有符号的，另一个操作数为无符号的，且无符号操作数的级别比有符号操作数高，则将有符号操作数转换为无符号操作数所属的类型。
7. 否则，如果有符号类型可表示无符号类型的所有可能取值，则将无符号操作数转换为有符号操作数所属的类型。
8. 否则，将两个操作数都转换为有符号类型的无符号版本。





1. 有符号整型按级别从高到低依次为`long long`、`long`、`int`、`short`和`signed char`。
2. 无符号整型的排列顺序与有符号整型相同。
3. 类型`char`、`signed char`和`unsigned char`的级别相同。
4. 类型`bool`的级别最低。
5. `wchar_t`、`char16_t`和`char32_t`的级别与其底层类型相同。
6. 这些规则确保了在进行类型转换时不会损失数据，并使得计算机能以最快的速度进行运算。
7. 不同版本的C++和C语言在这些规则上可能有所不同。例如，传统的C语言总是将`float`提升为`double`，即使两个操作数都是`float`。



## 3. 传递参数时的转换

传递参数时的类型转换通常由C++函数原型控制，可以取消原型对参数传递的控制。

在这种情况下，C++将对char和short类型(signed和 unsigned)应用整型提升，C++将 float参数提升为double。



这一部分还有疑问。



## 3. 强制类型转换

这是一种显式地改变变量类型的方式，有两种基本的强制类型转换格式：

1. `(typeName)value`：这种格式来自C语言，它会将`value`转换为`typeName`类型。
2. `typeName(value)`：这种格式是纯粹的C++，它的想法是让强制类型转换看起来像是函数调用。



C++还引入了4个强制类型转换运算符，其中`static_cast<typeName>(value)`可以用于将值从一种数值类型转换为另一种数值类型。

它的使用更为严格，只能在类型之间进行转换，这些类型之间的转换在编译时是安全的。

例如，你可以这样将`thorn`转换为`long`类型：

```cpp
static_cast<long>(thorn) // 返回thorn的long类型转换
```





## 4. 列表初始化

使用大括号 `{}` 来初始化变量，常用于给复杂的数据类型提供值列表。

列表初始化对类型转换的要求更严格，它不允许缩窄（narrowing），例如，不允许将浮点型转换为整型。



在不同的整型之间转换或将整型转换为浮点型可能被允许，条件是编译器知道目标变量能够正确地存储赋给它的值。

例如，可以将 `long` 变量初始化为 `int` 值，因为 `long` 总是至少与 `int` 一样长；相反方向的转换也可能被允许，只要 `int` 变量能够存储赋给它的 `long` 常量。



# 精度丢失

## 1. 潜在的数值转换问题

1. 将一个值赋给值取值范围更大的类型通常不会导致什么问题。
2. 将0赋给 bool变量时，将被转换为false;而非零值将被转换为true。
3. 将浮点值转换为整型会将数字截短(除掉小数部分)。
4. float 值对于 int 变量来说可能太大了。

在这种情况下，C++并没有定义结果应该是什么；这意味着不同的实现（编译器）的反应可能不同。

| 转换                                                         | 潜在的问题                                                   |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| 将较大的浮点类型转换为较小的浮点类型，如将 `double` 转换为 `float` | 精度（有效数位）降低，值可能超出目标类型的取值范围，在这种情况下，结果将是不确定的 |
| 将浮点类型转换为整型                                         | 小数部分丢失，原来的值可能超出目标类型的取值范围，在这种情况下，结果将是不确定的 |
| 将较大的整型转换为较小的整型，如将 `long` 转换为 `short`     | 原来的值可能超出目标类型的取值范围，通常只复制右边的字节     |



## 2. 除法问题

如果两个操作数都是整数，那么 C++ 将执行整数除法。这意味着结果的小数部分将被丢弃，使得最后的结果是一个整数。例如，`5 / 2` 的结果是 `2`，而不是 `2.5`。

如果至少有一个操作数是浮点数，那么结果的小数部分将保留，结果为浮点数。例如，`5.0 / 2` 或 `5 / 2.0` 的结果是 `2.5`。



