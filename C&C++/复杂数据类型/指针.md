# 指针

## 1. 定义

指针声明必须指定指针指向的数据的类型。

char 的地址与double 的地址看上去没什么两样，但 char 和 double 使用的字节数是不同的，它们存储值时使用的内部格式也不同。

```
int *p_updates;
```

p_updates 指向 int 类型，`p_updates`是指针(地址)，而`*pupdates`是int。



- `int *ptr;`：C风格，强调`*ptr`是`int`类型的指针。
- `int* ptr;`：C++风格，强调`int*`是指向`int`的指针类型。
- `int*ptr;`：也是合法的，但不常用。
- `int* p1, p2;`：`p1`是`int`类型指针，`p2`是普通`int`变量。



可以用同样的句法来声明指向其他类型的指针：

```
double *tax_ptr; 	//tax_ptr是一个指向double类型的指针。
char *str;			//str是一个指向char类型的指针。
```



**地址长度和作用**：虽然 tax ptr 和 str 指向两种长度不同的数据类型，但这两个变量本身的长度通常是相同的。

因为char 的地址与 double的地址的长度相同，这就好比 1016可能是超市的街道地址，而 1024 可以是小村庄的街道地址一样。

地址的长度或值既不能指示关于变量的长度或类型的任何信息，也不能指示该地址上有什么建筑物。



**指针类型的作用**：

针必须声明所指向的类型，因为地址本身只提供了内存的起始位置，没有提供类型或长度信息。

例如，`int* pt`和`double* pd`的长度相同，都是地址。

但由于声明了指针的类型，程序知道`*pd`是8字节的`double`值，`*pt`是4字节的`int`值。当打印`*pd`的值时，需要读取多少字节以及如何解释它们。













## 2. 赋值

不能直接将整数赋给指针，需要强制类型转换：

```
int *pt;
pt = 0xB8000000;		//非法
pt = (int*)0xB8000000;	//合法
```



## 3. 运算

指针和整数是不同的类型。

整数是数字，可以进行加减乘除等运算。

指针是地址，描述位置，**不能进行乘除法等运算**。





## 4. 危险的指针

创建指针时，系统只分配存储地址的内存，不分配存储数据的内存。例如：

```cpp
long *fellow;
fellow = 223323;  // 错误！fellow未初始化，它的值是未知的
```



这里，`fellow`是一个指针，但我们并没有给它一个有效的地址，而是试图在一个未知的、可能无效的地址上存储值`223323`。这可能导致严重的错误，包括覆盖程序代码或其他重要数据。

**警告**：在使用指针之前，一定要将其初始化为一个确定的、适当的地址。





# 指针和数组的访问

## 1. 下标法

这是最常见的方式，我们可以通过数组名和索引来访问数组中的元素。例如，如果我们有一个数组`arr`，我们可以通过`arr[i]`来访问第`i+1`个元素。

```cpp
int arr[5] = {1, 2, 3, 4, 5};
std::cout << arr[0]; // 输出第一个元素，结果为1
```



## 2. 偏移法

在C++中，数组名实际上是指向数组第一个元素的指针。因此，我们可以通过指针来访问数组中的元素。例如，如果我们有一个指针`p`指向数组`arr`，我们可以通过`*(p+i)`或者`p[i]`来访问第`i+1`个元素。

由于取值运算符`*`的优先级高于算数运算符，所以必须要使用括号。

p+1，其中p是指针，指向数组的首地址，1表示的是数组中的第1个元素。

假设int类型占4字节，p指向的地址为0x8000，那么p+1的结果为0x8004，p+2的结果为0x8008。

假设double类型占8字节，p指向的地址为0x8000，那么p+1的结果为0x8008，p+2的结果为0x8016。

```cpp
int arr[5] = {1, 2, 3, 4, 5};
int* p = arr;
std::cout << *p;     // 输出第一个元素，结果为1
std::cout << *(p+1); // 输出第二个元素，结果为2
std::cout << p[2];   // 输出第三个元素，结果为3
```



# 动态内存



## 1. 分配空间

在C语言中，可以使用malloc函数分配内存空间。



在C++中，可以使用`new`运算符在运行时为数据对象（包括基本类型和结构）分配未命名的内存。例如：

```cpp
int *pn = new int;  // 为int类型分配内存，并将地址赋给pn
```

为一个数据对象(可以是结构，也可以是基本类型)获得并指定分配内存的通用格式如下:

```cpp
typeName *pointer name =n ew typeName;
```



`new`可能无法分配内存，通常会引发异常或返回0（空指针）。空指针不会指向有效数据，常用来表示失败。



## 2. 释放内存

`delete`用于释放`new`分配的内存空间



1. 当不再需要某块内存时，可以使用 `delete` 来释放这块内存。

2. 对空指针使用 delete 是安全的。

3. `delete` 只会释放指针所指向的内存，而不会删除指针本身，指针可以指向其他的内存空间。

4. 不要尝试释放已经释放的内存块，C++标准指出，这样做的结果将是不确定的。

5. 它用于 new分配的内存。这并不意味着要使用用于 new的指针，而是用于new的地址。

    ```cpp
    int *ps = new int; // 分配内存
    int *pq = ps; // 将第二个指针指向同一块内存
    delete pq; // 使用第二个指针删除
    ```



## 3. new创建动态数组

在C++中，创建动态数组很容易，只要将数组的元素类型和元素数目告诉`new`即可。例如，要创建一个包含10个`int`元素的数组，可以这样做：

```cpp
int *psome = new int[10]; // 获取10个int的内存块
```



`new`运算符返回第一个元素的地址。在这个例子中，该地址被赋给指针`psome`。当程序使用完`new`分配的内存块时，应使用`delete`释放它们。然而，对于使用`new`创建的数组，应使用另一种格式的`delete`来释放：

```cpp
delete [] psome; // 释放动态数组
```



方括号告诉程序，应释放整个数组，而不仅仅是指针指向的元素。如果使用`new`时不带方括号，则使用`delete`时也不应带方括号。如果使用`new`时带方括号，则使用`delete`时也应带方括号。



