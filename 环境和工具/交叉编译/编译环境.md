# 编译环境

C/C++编译环境

1. 首先最主要是编译器所支持的CPU架构，X86或ARM。

2. 操作系统平台，Windows为PE文件，Linux为ELF文件。（在这里只介绍Linux下的编译）

3. C标准库（Glibc、musl-libc）版本。
4. X86_64CPU架构

5. 第三方库（如openssl、python-dev等）。



## 机器架构

目标机器是的CPU架构是X86就选择X86编译器，如果是ARM架构就选择ARM编译器。

编译机器为X86，目标机器为ARM，那就要选择X86编译ARM的编译器。以下是几个常见的：

1. **ARMCC (ARM Compiler)**:
    - 由ARM公司提供，专门针对ARM架构优化，通常与Keil MDK或Arm Development Studio一起使用。
    - 生成的代码往往在性能上有很好的优化。
    - 商业软件，可能需要购买许可。
2. **IAR Embedded Workbench for ARM**:
    - IAR Systems开发，广泛用于嵌入式系统开发。
    - 提供了优秀的调试工具和优化的代码生成。
    - 也是商业软件，适合需要高级调试功能和良好技术支持的项目。
3. **GCC for ARM (GNU Compiler Collection)**:
    - 开源且免费，广泛支持各种ARM架构。
    - 社区活跃，生态丰富，有许多第三方库和工具支持。
    - 对于预算有限或者偏好开源解决方案的项目非常合适。
4. **LLVM (with clang)**:
    - LLVM是一个模块化和可重用的编译器基础设施项目，clang是其C/C++前端。
    - 支持跨平台编译，包括ARM，且在不断改进对ARM架构的支持和优化。
    - 提供现代编译技术和良好的错误报告，适合需要高度灵活性和先进编译技术的场景。



只要你的编译机器是X86，目标机器是ARM，那么以上编译器编译出来的程序，都可以在ARM机器上运行，CPU版本并不重要，只不过不同编译器编译出来的，只是执行效率等会有不同。



## ELF文件

PE文件是Widnows下可执行程序文件的格式，ELF文件是Linux下可执行程序文件的格式。

PE只能在Windows下运行，ELF只能在Linux下运行。



如果编译机器是Windows，目标机器是Linux，则需要使用编译程序为PE，编译的目标程序为ELF。



## libc版本

libc是C语言的标准函数库，它既包括静态库文件，也包括动态库文件。它包含了C语言所有库函数的实现（例如：printf、scanf等函数）。

如果是在Linux编译本机的C程序，则不需要考虑libc的问题，因为Linux操作系统安装时就自带相关的libc。



如果是在X86下编译ARM的程序，则需要先知道目标主机的libc版本，然后提前编译好对应libc，在编译程序时指定该libc。

在编译时指定libc时，可以选择使用动态链接库，或者静态链接库。

如果使用动态链接库，则程序在执行时会去搜索主机上对应的libc动态链接库，此时就必须保证目标主机上存在该版本的libc库。

如果使用静态链接库，则所使用的libc库会打包到程序中，则不需要考虑目标主机上是否存在这个版本的libc库，但是编译出来的程序所占用存储空间会更大。



## X86_64

CPU不仅区分X86和ARM，在X86架构中还有32位和64位之分。在64位的CPU中，可以编译64和32两者的程序，也可以运行64和32两者的程序。在32位CPU中，只能编译和运行32位CPU架构。



64位的程序需要64位的libc，32位的程序需要32位的libc。Linux是64位是肯定自带64位的libc，但是不一定携带32位的libc。如果你在64位的操作系统中，可能需要使用包管理器（例如dnf、apt）安装32位的libc，或者手动编译32位的glibc。



## 第三方库

C程序免不了使用标准库函数，所以是必须要libc的。但是部分程序还可能使用openssl、python-dev这样的第三方库文件，如果使用到了。

首先需要先编译第三方库，然后在编译程序的时候需要指定第三方库文件进行编译。

这里使用动态编译和静态编译也有区别。



# 编译GCC

**指定目标体系结构**：使用`--target`选项指明你想要构建的交叉编译器的目标架构。例如，如果你的目标平台是ARM，可能会使用`arm-linux-gnueabi`或`aarch64-linux-gnu`等作为目标。

```
./configure --target=aarch64-linux-gnu
```



**系统库和头文件**：对于某些目标架构，你可能需要提供或指定目标系统的库和头文件路径，以便GCC能够正确地链接和编译。这通常通过`--with-sysroot`或`--with-libc-header-dir`等选项完成。

```
./configure --with-sysroot=/path/to/sysroot
```



**多线程支持**：如果目标平台支持多线程，你可能需要启用并指定正确的线程模型和多核支持。例如，对于许多嵌入式Linux系统：

```
./configure --enable-multilib --with-threads=posix
```



要修改GCC编译后可执行文件（如`gcc`和`g++`）的名字，使其前面带有特定前缀，你需要在配置GCC源代码时使用`--program-prefix`选项。

```
./configure --program-prefix=xxx-yyy-zzz-
```



```
../configure --prefix=/root/envir/gcc-14.1/ --with-libc-header-dir=/root/envir/glibc64/ --enable-languages=c,c++ --program-prefix=x86_64-unknown-linux-gnu-
```

