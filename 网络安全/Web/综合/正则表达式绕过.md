# 正则表达式绕过



# 正则表达式回溯法原理

## 1. 没有回溯的匹配

假设我们的正则是/ab{1,3}c/

而当目标字符串是"abbbc"时，就没有所谓的“回溯”。其匹配过程是：

![img](images/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%BB%95%E8%BF%87.assets/v2-c243a389665b1ffbc0c33cf11143d8aa_1440w.png)

## 2. 有回溯的匹配

![img](images/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%BB%95%E8%BF%87.assets/v2-3ed842f1e3360394e59e184accac20a1_1440w.png)



1. 图中第5步有红颜色，表示匹配不成功。
2. 此时b{1,3}已经匹配到了2个字符“b”，准备尝试第3个b时，结果发现接下来的字符是“c”，那么就认为b{1,3}就已经匹配完毕。
3. 然后状态又回到之前的状态（即第6步，与第4步一样），最后再用子表达式c，去匹配字符“c”。
4. 字符串c匹配成功，当然，此时整个表达式匹配成功了。

图中的第6步，就是“回溯”。



/".*"/

目标字符串是："acd"ef，匹配过程是：

![img](images/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%BB%95%E8%BF%87.assets/v2-c893d2c3fcaad88c7de4dbf52540d4fc_1440w.png)



之前的例子都是贪婪量词相关的。比如b{1,3}，因为其是贪婪的，尝试可能的顺序是从多往少的方向去尝试。首先会尝试"bbb"，然后再看整个正则是否能匹配。不能匹配时，吐出一个"b"，即在"bb"的基础上，再继续尝试。如果还不行，再吐出一个，再试。如果还不行呢？只能说明匹配失败了。



### 贪婪量词

此处的`/".*"/`也是如此，首先匹配`"`然后`.*`会匹配所有的字符，直到末尾才反应过来还有一个`"`没有匹配到，所以会尝试吐出一个字符，不行。吐出两个字符，不行。吐出三个字符，匹配到"字符了，至此，匹配技术。



### 惰性量词

惰性量词就是在贪婪量词后面加个问号。表示尽可能少的匹配，比如：

```javascript
var string = "12345";
var regex = /(\d{1,3}?)(\d{1,3})/;
console.log( string.match(regex) );
// => ["1234", "1", "234", index: 0, input: "12345"]
```



其中\d{1,3}?只匹配到一个字符"1"，而后面的\d{1,3}匹配了"234"。

虽然惰性量词不贪，但也会有回溯的现象。



正则：`/^\d{1,3}?\d{1,3}$/`

目标字符串是"12345"

![img](images/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%BB%95%E8%BF%87.assets/v2-4bdddc108169c5ccc7968cd2307c3a69_1440w.png)

\d{1,3}表示匹配1-3个数字字符，由于后面有?表示惰性量词，这里最少只要匹配一个就符合条件，所以只匹配了一个就满足了`\d{1,3}?`开始匹配`\d{1,3}$`，匹配了三个后发现没有末尾，整体无法匹配成功，所以进行了回溯，让`\d{1,3}?`匹配了两个数字字符。



## 分支匹配结构

我们知道分支也是惰性的，比如/can|candy/，去匹配字符串"candy"，得到的结果是"can"，因为分支会一个一个尝试，如果前面的满足了，后面就不会再试验了。

分支结构，可能前面的子模式会形成了局部匹配，如果接下来表达式整体不匹配时，仍会继续尝试剩下的分支。这种尝试也可以看成一种回溯。

正则：/^(?:can/candy)$/

目标字符串是"candy"

![img](images/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%BB%95%E8%BF%87.assets/v2-6802fdf7edc0d086fb8793937ba9452d_1440w.png)

首先分支时惰性的，尝试匹配最少的can匹配成功，但是匹配下一个字符的时候没有匹配成功，然后尝试匹配第二少的candy，匹配成功 了，再去匹配末尾。



回溯法也称试探法，它的基本思想是：从问题的某一种状态（初始状态）出发，搜索从这种状态出发所能达到的所有“状态”，当一条路走到“尽头”的时候（不能再前进），再后退一步或若干步，从另一种可能“状态”出发，继续搜索，直到所有的“路径”（状态）都试探过。这种不断“前进”、不断“回溯”寻找解的方法，就称作“回溯法”。



参考链接原文:[正则表达式回溯法原理 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/27417442)



## ctf例题：

![image-20231103102250199](images/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%BB%95%E8%BF%87.assets/image-20231103102250199.png)

分析：

首先从通过POST获取xdmtql变量，判断此变量是否为一个数组，不是数组的话执行后面的内容。

将xdmtql变量进行正则表达式匹配，如果匹配不成功则继续执行

将xqmtql变量进行字符串匹配，如果为**sys nb**则返回flag值



由于正则表达式使用了.*，且是贪婪量词，则可以使用最大回溯限制进行绕过。

构造payload：`data = {"xdmtql": "sys nb" + "a" * 1000000}`



python：

```python
import requests
data = {"xdmtql": "sys nb" + "a" * 999999}
res = requests.post('http://07014002-7beb-455f-9656-dd0b01b8620b.www.polarctf.com:8090/', data=data, allow_redirects=False)
print(res.content)
```



preg_match函数：

preg_match函数，返回 pattern 的匹配次数。 它的值将是 0 次（不匹配）或 1 次，因为 preg_match() 在第一次匹配后 将会停止搜索。

preg_match函数只能匹配一个字符串，如果传入的是数组的话，也会返回false。

preg_match ()函数回溯次数超过最大限制，返回false，默认最大次数100万次。



回溯绕过一般用于在post传输参数的时候使用，因为get传输参数是通过url进行的，所以要考虑url的长度限制，在http1.1协议中，url没有进行限制的，但是客户端（浏览器）或者服务器可能会对url进行限制