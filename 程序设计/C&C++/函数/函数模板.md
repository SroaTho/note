# 函数模板

函数模板是一种特殊的函数，可以处理不同的数据类型，但是处理方式相同。这种函数的定义方式称为函数模板。

函数模板的定义格式如下：

```cpp
template <typename T>
函数返回类型 函数名(参数列表)
{
    // 函数体
}
```



其中，`template <typename T>`是模板声明，表示声明一个模板，`T`是类型参数，可以用来代表任何类型。

在标准 C++98 添加关键字 typename 之前，C++使用关键字 class 来创建模板。

下面是一个使用函数模板来交换两个`int`和`double`类型的值的示例：

```cpp
template <typename T>
void swap(T& a, T& b) {
    T temp = a;
    a = b;
    b = temp;
}

int main() {
    int i1 = 1, i2 = 2;
    double d1 = 1.1, d2 = 2.2;
    swap(i1, i2);  // 交换两个int类型的值
    swap(d1, d2);  // 交换两个double类型的值
    return 0;
}
```



## 1. 模板重载

模板重载是一种在C++中使用模板的高级技术，它允许我们为不同的类型或参数定义不同的模板函数。

有两个`Swap`函数模板，第一个模板用于交换两个值，而第二个模板用于交换两个数组中的元素。这两个模板的函数特征标是不同的，所以它们可以同时存在。

第一个模板的函数特征标为`(T&, T&)`，它接受两个引用参数，用于交换两个值：

```cpp
template <typename T>
void Swap(T &a, T &b) {
    T temp = a;
    a = b;
    b = temp;
}
```



第二个模板的函数特征标为`(T[], T[], int)`，它接受两个数组和一个整数，用于交换两个数组中的元素：

```cpp
template <typename T>
void Swap(T *a, T *b, int n) {
    for (int i = 0; i < n; i++) {
        T temp = a[i];
        a[i] = b[i];
        b[i] = temp;
    }
}
```



## 2. 模板的局限性

模板也有其局限性：

1. **类型限制**：模板函数假定可以对其类型参数执行某些操作。例如，如果你的模板函数中有一个赋值操作`a = b`，那么这个模板就不能用于数组类型，因为数组不支持赋值操作。
2. **操作符限制**：模板函数可能会假定其类型参数支持某些操作符。例如，如果模板函数中有一个比较操作`if (a > b)`，那么这个模板就不能用于结构类型，因为结构类型默认不支持`>`操作符。
3. **通用性与特殊性的冲突**：有时，我们希望模板能够处理一些特殊的情况，但是C++的语法可能不允许。例如，我们可能希望一个模板函数能够处理两个包含位置坐标的结构的相加操作，但是C++默认并不支持结构的加法操作。

为了解决这些问题，C++提供了一些解决方案：

- **运算符重载**：我们可以为特定的结构或类重载某些运算符，使得模板函数可以处理这些类型。例如，我们可以重载`+`运算符，使得模板函数可以处理包含位置坐标的结构的相加操作。
- **模板特化**：我们可以为特定的类型提供具体化的模板定义，以处理这些类型的特殊情况。例如，我们可以为数组类型提供一个特化的模板，以处理数组的赋值操作。



## 3. 显示具体化

我们为某个特定类型提供一个特殊的模板实现时，我们称之为显式具体化。

例如，假设我们有一个模板函数`print`，用于打印各种类型的值：

```cpp
template <typename T>
void print(const T& value) {
    std::cout << value << std::endl;
}
```



这个模板函数可以打印任何类型的值，只要这个类型支持`<<`操作符。然而，如果我们想要为`std::vector`类型提供一个特殊的打印方式，我们就可以使用显式具体化：

```cpp
template <>
void print(const std::vector<int>& vec) {
    for (const auto& value : vec) {
        std::cout << value << ' ';
    }
    std::cout << std::endl;
}
```



在这个显式具体化的版本中，我们遍历`std::vector`，并打印出每个元素。注意，显式具体化的模板前面有一个额外的`<>`，这是显式具体化的标志。

当我们调用`print`函数时，如果参数是`std::vector<int>`类型，编译器就会选择显式具体化的版本。如果参数是其他类型，编译器就会选择通用的模板版本。



## 4. 隐式实例化、显式实例化、显式具体化

1. **隐式实例化**：当我们在代码中使用模板函数或模板类时，编译器会根据我们提供的类型参数，自动生成一个特定的函数或类。例如，如果我们有一个模板函数`Swap<T>(T&, T&)`，当我们调用`Swap<int>(int&, int&)`时，编译器就会生成一个处理`int`类型的`Swap`函数。
2. **显式实例化**：这是我们明确告诉编译器要生成某个特定类型的模板实例。例如，`template void Swap<int>(int, int);`就是一个显式实例化的声明，它告诉编译器我们希望生成一个处理`int`类型的`Swap`函数。

3. **具体化**：是为特定类型提供特殊的模板实现。例如，`template <> void Swap<int>(int&, int&);` 是一个显式具体化的`Swap`函数，专为`int`类型设计。





