

# 类作用域

在类中定义的名称(如类数据成员名和类成员函数名)的作用域都为整个类，作用域为整个类的名称只在该类中是已知的，在类外是不可知的。



不能从外部直接访问类的成员和公有成员函数，必须通过对象：

```cpp
Book english;
cout << english.name << endl;
english.display();
```



在定义成员函数时，必须使用作用域解析运算符：

```cpp
void Book::update(double price){
	...
}
```



在类声明或成员函数定义中，可以直接使用成员的名称，无需任何修饰。例如，在类的成员函数`sel()`中可以直接调用另一个成员函数`set_tot()`。

**成员运算符的使用**：在其他情况下，访问类的成员需要使用特定的运算符：

- **直接成员运算符(.)**：当对象是实体（非指针）时，使用`.`来访问其成员。
- **间接成员运算符(->)**：当对象是指针时，使用`->`来访问其成员。
- **作用域解析运算符(::)**：用于访问类的静态成员，或者在类外部访问类的成员。



## 静态类成员

在类中，不能直接定义一个常量并给它赋值，因为类的定义只是一个模板，它并没有创建任何实际的对象，所以没有地方存储这个常量的值。例如，下面的代码是错误的：

```cpp
class Book {

public:
	 
	 const int length = 10;	// 这是不允许的

};
```



静态类成员与其他静态变量存储在一起，而不是存储在对象中，所以可以静态类成员是可以有初始值的，例如：

```cpp
class Book {

public:
	 
	 static const int length = 10;	// 这是允许的， 因为前面加了static变成了静态类常量

};
```



## 类中使用枚举

枚举在类中的作用域是整个类，所以我们可以用枚举来为整个类提供一个常量。例如：

```cpp
class Bakery {
private:
    enum { Months = 12 };
    double costs[Months];
};
```

`Months` 是一个符号名称，它在整个类的作用域内都可以使用，并且编译器会自动用 `12` 来替换它。

这种方式并不会在类中创建一个数据成员，也就是说，所有的对象都不包含这个枚举（指这个枚举不会占用对象的存储空间）。



## 枚举类

C++11引入了一种新的枚举类型，称为限定作用域的枚举类型（scoped enumeration），也被称为枚举类（enum class）。这种新的枚举类型解决了传统枚举类型的一些问题，并提供了更好的类型安全性和可读性。

以下是限定作用域的枚举类型的定义方式：

```cpp
enum class Color {Red, Green, Blue};
```



- 作用域：限定作用域的枚举类型的枚举值被限定在特定的作用域内，需要通过作用域解析操作符::来访问。例如，Color::Red。
- 类型安全：限定作用域的枚举类型是类型安全的，不能隐式地转换为其它类型，这有助于避免意外的错误。
- 命名冲突：在不同的作用域中可以使用相同的枚举值而不会发生命名冲突。



这是一个使用限定作用域的枚举类型的例子：

```cpp
enum class Color {Red, Green, Blue};
Color myColor = Color::Red;
```

Color::Red是一个枚举值，它在Color的作用域内。你不能直接使用Red，必须使用Color::Red。



不能将Color::Red隐式地转换为一个整数，整形运算和关系运算符都不能有枚举类：

```cpp
int x = Color::Red; // 不被允许的
if( Color::Red > 10) { ... }  //不被允许的
```



如果需要将其转换为一个整数，你必须使用强制类型转换：

```cpp
int x = int(Color::Red);
int y = int(Color::Red) + x + 10;
```

