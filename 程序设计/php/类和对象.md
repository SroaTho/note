# 类与对象

## 类的概念

类以关键字 **class** 开头，后面跟上类名，后面跟着一对花括号，里面包含有类的属性与方法的定义。

一个类可以包含有属于自己的 常量，变量（称为“属性”）以及函数（称为“方法”）。

**示例 #1 简单的类定义**

```php
<?php
class SimpleClass
{
    // 声明属性
    public $var = 'a default value';

    // 声明方法
    public function displayVar() {
        echo $this->var;
    }
}
?>
```



**示例 #2 使用 $this 伪变量的示例**

伪变量 $this 是一个到当前对象的引用。

以静态方式去调用一个非静态方法，在 PHP 8.0.0 之前版本中，将会产生一个废弃通知，在 PHP 8.0.0 之后将会抛出一个 Error。

```php
<?php
class A
{
    function foo()
    {
        if (isset($this)) {
            echo '$this is defined (';
            echo get_class($this);
            echo ")\n";
        } else {
            echo "\$this is not defined.\n";
        }
    }
}

class B
{
    function bar()
    {
        A::foo();
    }
}

$a = new A();
$a->foo();

A::foo();

$b = new B();
$b->bar();

B::bar();
?>
```

以上示例在 PHP 7 中的输出：

```
$this is defined (A)

Deprecated: Non-static method A::foo() should not be called statically in %s  on line 27
$this is not defined.

Deprecated: Non-static method A::foo() should not be called statically in %s  on line 20
$this is not defined.

Deprecated: Non-static method B::bar() should not be called statically in %s  on line 32

Deprecated: Non-static method A::foo() should not be called statically in %s  on line 20
$this is not defined.
```

以上示例在 PHP 8 中的输出：

```
$this is defined (A)

Fatal error: Uncaught Error: Non-static method A::foo() cannot be called statically in %s :27
Stack trace:
#0 {main}
  thrown in %s  on line 27
```



### 只读类

PHP 8.2.0 readonly 修饰符来标记类，向每个声明的属性添加 readonly 修饰符并禁止创建动态属性。

仅当子类也是 readonly 类时，才可以继承 readonly 类。

无类型的属性和静态属性不能用 readonly 修饰符。

```php
<?php
readonly class Foo
{
    public $bar;
    
    // Fatal error: Readonly property Foo::$bar must have type
    
    public static int $bar;
    
    // Fatal error: Readonly class Foo cannot declare static properties
}


?>
```



### new

new 关键字，创建一个类的实例。当创建新对象时该对象总是被赋值，除非该对象定义了 **构造函数** 并且在出错时抛出了一个 **异常**。

类应在被实例化之前定义（某些情况下则必须这样）。





**示例 #3 创建实例**

如果一个变量包含一个类名的 string 和 new 时，将创建该类的一个新实	例。 如果该类属于一个命名空间，则必须使用其完整名称。

注意：如果没有参数要传递给类的构造函数，类名后的括号则可以省略掉。

```php
<?php
$instance = new SimpleClass();

// 也可以这样做：
$className = 'SimpleClass';
$instance = new $className(); // new SimpleClass()
?>
```



**示例 #4 使用任意表达式创建实例**

PHP 8.0.0 起，支持任意表达式中使用 new 。

如果表达式生成一个 string，这将允许更复杂的实例化。表达式必须使用括号括起来。



多个生成类名的任意有效表达式的示例：函数调用，string 连接和 ::class 常量

```php
<?php

class ClassA extends \stdClass {}
class ClassB extends \stdClass {}
class ClassC extends ClassB {}
class ClassD extends ClassA {}

function getSomeClass(): string
{
    return 'ClassA';
}

var_dump(new (getSomeClass()));
var_dump(new ('Class' . 'B'));
var_dump(new ('Class' . 'C'));
var_dump(new (ClassD::class));
?>
```

以上示例在 PHP 8 中的输出：

```
object(ClassA)#1 (0) {
}
object(ClassB)#1 (0) {
}
object(ClassC)#1 (0) {
}
object(ClassD)#1 (0) {
}
```



**示例 #5 对象赋值**

在 PHP 中，当你将一个对象实例赋值给另一个变量时，实际上并不是复制了这个对象，而是创建了一个新的引用（reference），两个变量指向的是内存中的同一个对象实例。

```php
<?php

$instance = new SimpleClass();

$assigned   =  $instance;
$reference  =& $instance;

$instance->var = '$assigned will have this value';

$instance = null; // $instance 和 $reference 变为 null

var_dump($instance);
var_dump($reference);
var_dump($assigned);
?>
```

以上示例会输出：

```
NULL
NULL
object(SimpleClass)#1 (1) {
   ["var"]=>
     string(30) "$assigned will have this value"
}
```



详细解释一下你代码片段：

```
$instance = new SimpleClass();
$assigned   =  $instance;       // 创建对 $instance 指向对象的引用
$reference  =& $instance;      // 创建对 $instance 变量本身的引用
```

- 由于 $assigned **是引用**的 $instance 变量**指向的对象**，**而不是**引用 $instance **变量本身**，所以修改 $instance 的值会不影响到 $assigned 。

- 而 $reference 是引用的 $instance **变量本身**，所以修改 $instance 的值，$reference的值也会跟着改变。



**示例 #6 创建新对象**

有几种方法可以创建一个对象的实例。

```php
<?php

class Test
{
    public static function getNew()
    {
        return new static();
    }
}

class Child extends Test {}

$obj1 = new Test(); // 通过类名
$obj2 = new $obj1(); // 通过包含对象的变量
var_dump($obj1 !== $obj2);

$obj3 = Test::getNew(); // 通过类方法
var_dump($obj3 instanceof Test);

$obj4 = Child::getNew(); // 通过子类方法
var_dump($obj4 instanceof Child);

?>
```

以上示例会输出：

```
bool(true)
bool(true)
bool(true)
```



**示例 #7 访问新创建对象的成员**

可以通过一个表达式来访问新创建对象的成员：

```php
<?php
echo (new DateTime())->format('Y');
?>
```

以上示例的输出类似于：

```
2016
```

> **注意**: 在 PHP 7.1 之前，如果类没有定义构造函数，则不对参数进行执行。



## 属性和方法

类的属性和方法存在于不同的“命名空间”中，同一个类的属性和方法可以使用同样的名字。



**示例 #8 访问类属性 vs. 调用类方法**

访问属性和调用方法使用同样的操作符，具体是访问一个属性还是调用一个方法，取决于你的上下文，即用法是变量访问还是函数调用。

```php
<?php
class Foo
{
    public $bar = 'property';

    public function bar() {
        return 'method';
    }
}

$obj = new Foo();
echo $obj->bar, PHP_EOL, $obj->bar(), PHP_EOL;
```

以上示例会输出：

```
property
method
```



**示例 #9 类属性被赋值为匿名函数时的调用示例**

访问类属性的优先级要更高，如果你的类属性被分配给一个 匿名函数 你将无法直接调用它，需要用括号包裹起来调用。

```php
<?php
class Foo
{
    public $bar;

    public function __construct() {
        $this->bar = function() {
            return 42;
        };
    }
}

$obj = new Foo();

echo ($obj->bar)(), PHP_EOL;
```

以上示例会输出：

```
42
```



## 继承 extends

类可以在声明中用 extends 关键字继承另一个类的方法和属性，PHP 不支持多重继承，一个类只能继承一个基类。

被继承的方法和属性可以通过用同样的名字重新声明被覆盖，如果父类定义方法或者常量时使用了 final，则不可被覆盖。

可以通过 parent:: 来访问被覆盖的方法或属性。

> **注意**: 从 PHP 8.1.0 起，常量可以声明为 final。



**示例 #10 简单的类继承**

```php
<?php
class ExtendClass extends SimpleClass
{
    // 同样名称的方法，将会覆盖父类的方法
    function displayVar()
    {
        echo "Extending class\n";
        parent::displayVar();
    }
}

$extended = new ExtendClass();
$extended->displayVar();
?>
```

以上示例会输出：

```
Extending class
a default value
```



## 签名兼容性规则

当覆盖（override）方法时，签名必须兼容父类方法。否则会导致 Fatal 错误，PHP 8.0.0 之前是 E_WARNING 级错误。

兼容签名是指：遵守协变与逆变规则；**强制参数可以改为可选参数；添加的新参数只能是可选；放宽可见性而不是继续限制**。

不过构造方法和私有（private）方法不需要遵循签名兼容规则，哪怕签名不匹配也不会导致 Fatal 错误。



**示例 #11 兼容子类方法**

```php
<?php

class Base
{
    public function foo(int $a) {
        echo "Valid\n";
    }
}

class Extend1 extends Base
{
    function foo(int $a = 5)
    {
        parent::foo($a);
    }
}

class Extend2 extends Base
{
    function foo(int $a, $b = 5)
    {
        parent::foo($a);
    }
}

$extended1 = new Extend1();
$extended1->foo();
$extended2 = new Extend2();
$extended2->foo(1);
```

以上示例会输出：

```
Valid
Valid
```



**示例 #12 子类方法移除参数后，导致 Fatal 错误**

```php
<?php

class Base
{
    public function foo(int $a = 5) {
        echo "Valid\n";
    }
}

class Extend extends Base
{
    function foo()
    {
        parent::foo(1);
    }
}
```

以上示例在 PHP 8 中的输出类似于：

```
Fatal error: Declaration of Extend::foo() must be compatible with Base::foo(int $a = 5) in /in/evtlq on line 13
```



**示例 #13 子类方法把可选参数改成强制参数，导致 Fatal 错误**

```php
<?php

class Base
{
    public function foo(int $a = 5) {
        echo "Valid\n";
    }
}

class Extend extends Base
{
    function foo(int $a)
    {
        parent::foo($a);
    }
}
```

以上示例在 PHP 8 中的输出类似于：

```
Fatal error: Declaration of Extend::foo(int $a) must be compatible with Base::foo(int $a = 5) in /in/qJXVC on line 13
```



重命名子类方法的参数名称也是签名兼容的。 然而我们不建议这样做，因为使用命名参数时， 这种做法会导致运行时的 Error。

**示例 #14 在子类中重命一个命名参数，导致 Error**

```php
<?php

class A {
    public function test($foo, $bar) {}
}

class B extends A {
    public function test($a, $b) {}
}

$obj = new B;

// 按 B::test() 的签名约定传入参数
$obj->test(a: "foo", b: "bar");

// 按 A::test() 的签名约定传入参数
$obj->test(foo: "foo", bar: "bar"); // ERROR!
```

以上示例的输出类似于：

```
foobar

Fatal error: Uncaught Error: Unknown named parameter $foo in \xxx\xxx.php:16
Stack trace:
#0 {main}
  thrown in xxx\xxx\.php on line 16
```



## ::class

关键词 class 也可用于类名的解析。使用 ClassName::class 可以获取包含类 ClassName 的完全限定名称。这对使用了 **命名空间** 的类尤其有用。

```php
<?php
namespace NS {
    class ClassName {
    }

    echo ClassName::class;
}
?>
```

以上示例会输出：

```
NS\ClassName
```



**示例 #16 解析不存在的类名**

注意：使用 ::class 解析类名操作会在底层编译时进行。这意味着在执行该操作时，类还没有被加载。 因此，即使要调用的类不存在，类名也会被展示。在此种场景下，并不会发生错误。

```php
<?php
print Does\Not\Exist::class;
?>
```

以上示例会输出：

```
Does\Not\Exist
```



**示例 #17 类名解析**

自 PHP 8.0.0 起，::class 也可用于对象。 与上述情况不同，此时解析将会在运行时进行。此操作的运行结果和在对象上调用 get_class() 相同。

以上示例会输出：

```
NS\ClassName
```



## Nullsafe 方法和属性

自 PHP 8.0.0 起，类属性和方法可以通过 "nullsafe" 操作符访问： ?->。 

除了一处不同，nullsafe 操作符和以上原来的属性、方法访问是一致的： 对象引用解析（dereference）为 null 时不抛出异常，而是返回 null。 

如果是链式调用中的一部分，剩余链条会直接跳过。



此操作的结果，类似于在每次访问前使用 is_null() 函数判断方法和属性是否存在，但更加简洁。



**示例 #18 Nullsafe 操作符**

```php
<?php

// 自 PHP 8.0.0 起可用
$result = $repository?->getUser(5)?->name;

// 上边那行代码等价于以下代码
if (is_null($repository)) {
    $result = null;
} else {
    $user = $repository->getUser(5);
    if (is_null($user)) {
        $result = null;
    } else {
        $result = $user->name;
    }
}
?>
```

注意：仅当 null 被认为是属性或方法返回的有效和预期的可能值时，才推荐使用 nullsafe 操作符。如果业务中需要明确指示错误，抛出异常会是更好的处理方式。
