# x86 Assembly

 NASM (Netwide Assembler) 的语法格式，是一种流行的 x86 和 x86-64 汇编器。



x86 处理器有 8 个 32 bit 寄存器

![img](./images/x86 Assembly.assets/x86-registers.png)

寄存器名字是早期计算机历史上 流传下来的。例如，EAX 表示 Accumulator，因为它用作算术运算的累加器，ECX 表示 Counter，用来存储循环变量（计数）。

大部分寄存器的名字已经失去了原来的意义，但有两个是例外：栈指针寄存器（Stack Pointer）ESP 和基址寄存器（ Base Pointer）EBP。

对于 `EAX`, `EBX`, `ECX`, `EDX` 四个寄存器，可以再将 32bit 划分成多个子寄存器， 每个子寄存器有专门的名字。

例如 `EAX` 的高 16bit 叫 `AX`（去掉 E, E 大概表示 **Extended**）,低 8bit 叫 `AL` (**Low**）, 8-16bit 叫 `AH` （**High**）。

在汇编语言中，这些寄存器的名字是**大小写无关**的，既可以用 `EAX`，也可以写 `eax`。



## EIP 指令寄存器

**注：在 x86-64 架构中，EIP 被扩展为 64 位，并重命名为 RIP（R15 Instruction Pointer）。**



EIP（Extended Instruction Pointer）是 x86 架构中的一个寄存器。

EIP 用于存储当前指令的地址，每当 CPU 执行完一条指令后，EIP 通常会自动递增到下一条指令的地址，从而控制程序的流程。



EIP寄存器不能使用 移动、加法、减法 等操作来更改，而是使用跳转操作来更改。



### jmp

jmp 将程序控制转移到指令流中的不同点，而不记录返回信息。

操作数指定要跳转到的指令的地址，此操作数可以是即时值、通用寄存器或内存位置。

```
global  _start

section .data
	adrs dd 0  ; 初始化为 0，稍后我们将把 skip 的地址存入这个位置

section .text
_start:
    mov ebx, 42
    mov eax, 1
    jmp skip
    
   ;jmp 0x00000000
   
   ;mov ecx,skip
   ;jmp ecx
   
   ;lea ecx, [skip]  ; 将 skip 标签的地址加载到 ecx 寄存器
   ;mov [adrs], ecx  ; 将 skip 的地址存入 adrs
   ;jmp [adrs]        ; 从 adrs 中读取地址，并跳转到该地址
   
    mov ebx, 13
skip:
    int 0x80
```



**扩展：条件转移指令参考 "EFLAG 标志寄存器" 部分**



##  EFLAG 标志寄存器

注：标志寄存器的名称在不同位CPU中有区别，16位为**FLAG**，32位为**EFLAG**，64位为**RFLAG**。



EFLAG寄存器用途，灰色位保留。

![img](./images/x86 Assembly.assets/f547c67fe9d872479f36f761f94b8a34.png)

**注：FLAG（16位）前16位与EFLAG一致；RFLAG（64位）前32位与EFLAG一致，后32位保留。**



### ZF

ZF是零标志位。它记录相关指令执行后，其结果是否为0。

- 如果计算结果为0，那么zf=1;
- 如果计算结果不为0，那么zf=0。



### PF

PF 是奇偶标志位。它记录相关指令执行后，其结果的所有 bit 位中 1的个数是否为偶数。

- 如果1的个数为偶数，pf=1；
- 如果1的个数为奇数，pf=0。



### SF

SF 是符号标志位。它记录相关指令执行后，其结果是否为负。

- 如果结果为负，sf=1;
- 如果结果非负，sf=0。



00000001B，可以看作为无符号数1，或有符号数+1;

10000001B，可以看作为无符号数129，也可以看作有符号数-127。



例1：

同一个二进制数据，计算机可以将它当作无符号数据来运算，也可以当作有符号数据来运算。比如:

```
mov al,10000001B
add al,1
```

结果：(al)=10000010B。

将 add 指令进行的运算当作**无符号数**的运算，那么 add 指令相当于计算 129+1,结果为 130(10000010B);

将 add 指令进行的运算当作**有符号数**的运算，那么 add 指令相当于计算-127+1，结果为-126(10000010B)。



例2：

```
mov al,10000001B
add al,01111111B
```

执行后，结果为 0，sf=0，表示：如果指令进行的是有符号数运算，那么结果为非负。



不管我们如何看待，CPU 在执行 add 等指令的时候，就已经包含了两种含义，也将得到用同一种信息来记录的两种结果。关键在于我们的程序需要哪一种结果。



### CF

CF 标志表示最近一次算术或逻辑操作是否产生了进位或借位。

- 当进行无符号加法时，如果最高有效位（MSB）产生了进位，则 CF 被置为 1；如果没有产生进位，则 CF 保持为 0。

  ```
  MOV EAX, 0xFFFFFFFF ; EAX = -1 (无符号为 4294967295)
  ADD EAX, 1          ; EAX + 1 = 0 (产生进位)
  ; 此时 CF = 1
  ```

- 当进行无符号减法时，如果 MSB 需要向更高位借位，则 CF 被置为 1；如果没有借位，则 CF 保持为 0。

  ```
  MOV EAX, 1
  SUB EAX, 2          ; EAX - 2 = -1 (无符号为 4294967295, 需要借位)
  ; 此时 CF = 1
  ```

  

### OF

OF 标志表示最近一次算术操作（通常是加法或减法）是否产生了带符号整数溢出。

- 当进行**带符号加法**时，如果正数加上正数的结果变成了负数，或者负数加上负数的结果变成了正数，则 OF 被置为 1；否则，OF 保持为 0。
- 当进行**带符号减法**时，如果正数减去负数的结果变成了负数，或者负数减去正数的结果变成了正数，则 OF 被置为 1；否则，OF 保持为 0。



### cmp

cmp 是比较指令，cmp的功能相当于减法指令，只是不保存结果。cmp指令执行后，将对标志寄存器产生影响。



### 条件转移指令

简化版本

| 指令 | 描述       | 有符号/无符号 | 检查的条件        |
| ---- | ---------- | ------------- | ----------------- |
| JE   | 当相等时   |               | ZF = 1            |
| JNE  | 当不等时   |               | ZF = 0            |
| JB   | 当小于     | 无符号        | CF = 1            |
| JNB  | 当大于等于 | 无符号        | CF = 0            |
| JA   | 当大于     | 无符号        | CF = 0 且 ZF = 0  |
| JNA  | 当小于等于 | 无符号        | CF = 1 或 ZF = 1  |
| JL   | 当小于     | 有符号        | SF ≠ OF           |
| JNL  | 当大于等于 | 有符号        | SF = OF           |
| JG   | 当大于     | 有符号        | ZF = 0 且 SF = OF |
| JNG  | 当小于等于 | 有符号        | ZF = 1 或 SF ≠ OF |



这些指令比较常用，它们都很好记忆，它们的第一个字母都是j，表示jump；后面的字母表示意义如下。

```
e:  表示 equal
ne: 表示 not equal
b:  表示 below
nb: 表示 not below
a:  表示 above
na: 表示 not above
l:  表示 less
nl: 表示 not less
g:  表示 greater
ng: 表示 not greater
```



完整版本

| 指令                 | 描述                                      | 有符号/无符号 | 检查的条件                   |
| -------------------- | ----------------------------------------- | ------------- | ---------------------------- |
| JO                   | 当发生溢出时跳转                          |               | OF = 1                       |
| JNO                  | 当没有发生溢出时跳转                      |               | OF = 0                       |
| JS                   | 当符号为负时跳转                          | 有符号        | SF = 1                       |
| JNS                  | 当符号为非负时跳转                        | 有符号        | SF = 0                       |
| JE / JZ              | 当相等时/当零时跳转                       |               | ZF = 1                       |
| JNE / JNZ            | 当不等时/当非零时跳转                     |               | ZF = 0                       |
| JP / JPE             | 当具有偶数位奇偶性时/当偶数位奇偶性时跳转 |               | PF = 1                       |
| JNP / JPO            | 当具有奇数位奇偶性时/当奇数位奇偶性时跳转 |               | PF = 0                       |
| JCXZ / JECXZ / JRCXZ | 当 CX/ECX/RCX 为零时跳转                  |               | CX = 0<br>ECX = 0<br>RCX = 0 |
| JB / JNAE / JC       | 当低于/当不大于或等于/当进位时跳转        | 无符号        | CF = 1                       |
| JNB / JAE / JNC      | 当不低于/当大于或等于/当没有进位时跳转    | 无符号        | CF = 0                       |
| JBE / JNA            | 当低于或等于/当不大于时跳转               | 无符号        | CF = 1 或 ZF = 1             |
| JA / JNBE            | 当高于/当不小于或等于时跳转               | 无符号        | CF = 0 且 ZF = 0             |
| JL / JNGE            | 当小于/当不大于或等于时跳转               | 有符号        | SF ≠ OF                      |
| JGE / JNL            | 当大于或等于/当不小于时跳转               | 有符号        | SF = OF                      |
| JLE / JNG            | 当小于或等于/当不大于时跳转               | 有符号        | ZF = 1 或 SF ≠ OF            |
| JG / JNLE            | 当大于/当不小于或等于时跳转               | 有符号        | ZF = 0 且 SF = OF            |



# 指令

## global

`global` 指令用于声明一个或多个全局符号。这些符号可以在链接阶段被其他模块引用。

在 NASM 中，`global` 指令通常用于标记程序的入口点（例如 `_start`），及其他需要在整个程序或链接单元中可见的函数或变量。



## section

**section** 指令用于定义一个段（section），它是程序的一部分，具有特定的属性和用途。常见的段有 `.text`、`.data` 和 `.bss`。	

#### 用途：

- **代码段**：`.text` 段包含可执行代码。
- **数据段**：`.data` 段包含初始化的数据。
- **未初始化数据段**：`.bss` 段包含未初始化的数据或零填充的数据。



```
global _start
section .text
_start:
    ; 可执行代码放在这里
```



# 段



## .text



## .data

`.DATA` 声明静态数据区。

数据类型修饰原语：

- `DB`: Byte		        1 Bytes
- `DW`: Word      	        2 Bytes
- `DD`: Double Word	4 Bytes



例子：单个变量，指向一个值

```
section .data
var     DB 64    ; 声明一个字节值，称为位置 var，包含值 64。
var2    DB ?     ; 声明一个未初始化的字节值，称为位置 var2。
        DB 10    ; 声明一个没有标签的字节值，包含值 10。它的位置是 var2 + 1。
X       DW ?     ; 声明一个 2 字节未初始化的值，称为位置 X。
Y       DD 30000 ; 声明一个 4 字节值，称为位置 Y，初始化为 30000。
```



例子：数组，指向第一个值的地址

```
section .data
Z       DD 1, 2, 3      ; 声明 3 个 4 字节的值，初始化为 1、2 和 3。位置 Z + 8 的值将是 3。
bytes   DB 10 DUP(?)    ; 声明 10 个未初始化的字节，从位置 bytes 开始。
arr     DD 100 DUP(0)   ; 声明 100 个 4 字节的单词，从位置 arr 开始，全部初始化为 0。
str     DB 'hello',0    ; 声明 6 个字节，从地址 str 开始，初始化为 "hello" 和空字符 (0)。
```



## .bss

