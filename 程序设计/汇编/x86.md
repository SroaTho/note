# xor

xor指令执行两个操作数之间的按位异或操作，并将结果存储在目标操作数的位置。源操作数可以是立即数、寄存器或内存位置；目标操作数可以是寄存器或内存位置。



xor ax, ax会将ax寄存器设置为02。这是因为异或操作在两个位不同时返回1，否则返回0。



# test

test指令执行两个操作数之间的按位与操作。该操作的结果会被丢弃，但是会修改标志寄存器。



# lea

lea（Load Effective Address）指令用于将操作数的有效内存地址存储到寄存器中。

它接受一个标准的内存寻址操作数，但除了将计算出的内存偏移量存储在指定的寄存器中外，不做任何其他操作。

例如，`lea rcx, [rsi + 4]`和`lea rax, [rsi + 0x14]`分别将`rsi + 4`和`rsi + 0x14`的地址加载到rcx和rax寄存器中。lea指令可以执行一系列简单的算术操作作为单个操作。



# enter

enter指令在调用函数时设置堆栈帧。调用一个函数时，需要先将rbp寄存器的值压入堆栈，然后将rsp寄存器的值复制到rbp寄存器，最后从rsp寄存器中减去一定的字节数。

换句话说，每次函数调用时都会执行以下指令（`enter N,0` 等价于）：

```
push rbp
mov rbp,rsp
sub rsp,N
```



# leave

leave 指令是enter指令的对应指令。即将`ebp`（或`rbp`）复制到`esp`（或`rsp`），然后从堆栈中恢复旧的`ebp`（或`rbp`）。leave指令等价于以下两条指令6：

```
mov rsp, rbp
pop rbp
```





# ENDBR64

“End Branch 64 bit”（ENDBR64）是一种特殊的汇编指令，它的主要作用是增强程序的安全性，防止黑客通过改变间接跳转的目标地址来攻击程序。

当CPU遇到一个间接跳转或调用指令时，"TRACKER"标志会被设置为"WAIT_FOR_ENDBRANCH"状态。在这个状态下，CPU会等待下一条指令。如果下一条指令是ENDBR64，那么"TRACKER"标志就会被设置回"IDLE"状态，程序继续执行。但是，如果下一条指令不是ENDBR64，那么CPU就会产生一个控制保护异常（#CP），程序就会被终止。

所以，"WAIT_FOR_ENDBRANCH"状态就是CPU在等待ENDBR64指令的状态，而"IDLE"状态则表示CPU当前没有在等待ENDBR64指令，可以正常执行其他指令。这两种状态的转换，就构成了ENDBR64指令的工作机制，用于防止黑客通过改变间接跳转的目标地址来攻击程序。