# 汇编语言

# 机器语言和汇编语言

## 机器语言

机器语言是机器指令的集合，机器指令展开来讲就是一台机器可以正确执行的命令。电子计算机的机器指令是一列二进制数字。

## 汇编语言

汇编语言的主体是汇编指令。汇编指令和机器指令的主要差别在于指令的表示方法上。汇编指令是机器指令便于书写的格式。

例如：机器指令10000100111011000表示把寄存器BX的内容送到AX中。汇编指令则携程mov ax,bx。这样的方法与人类语言接近，便于阅读和记忆。

```3#
操作：寄存器BX的内容送到AX中
机器指令：10000100111011000
汇编指令：mov AX,BX
```

### 汇编语言的组成

1. 汇编指令：机器码的助记符，有对应的机器码。
2. 伪指令：没有对应的机器码，由编译器执行，计算机并不执行。
3. 其他符号：如+、-、*、/等，由编译器识别，没有对应的机器码





# 指令和数据的区别

​		指令和数据是应用上的概念。在内存或硬盘上，指令和数据没有任何区别，都是二进制。例如，内存中的二进制信息`1000100111011000`，计算机可以把它看作大小为`89D8H`的数据来处理，也可以将其看作指令`mov ax,bx`来执行。



# 存储单元

存储器被划分为若干个存储单元，一个存储单元可以存储1Btye（字节），每个存储单元从0开始顺序编号（128个存储单元，编号0-127）



# CPU对存储器的读写

## 三类信息

CPU要进行数据的读写，必须和外部器件（标准的说法是芯片）进行下面3类信息的交互：

1. 存储单元的地址（地址信息）
2. 器件的选择，读或写的命令（控制信息）
3. 读或写的数据（数据信息）

## 总线

CPU连接其他芯片的导线，通常称为总线，总线从物理上来讲，就是一根根导线的集合。总线从逻辑上分为三类，地址总线、数据总线、控制总线

### 地址总线

CPU的寻址能力取决于总线上能传送多少不同的信息。现假设CPU有十根地址总线（导线），一根导线可以传递0或1两种信息，10根导线可以传递10位二进制，10为二进制数可以表示10的2次方个数据，也就是从0-1023。

PS:一颗CPU中的地址总线中导线的个数为n，那么该CPU的寻址能力为2的n次方，寻址范围为 0 - (2的n次方减1)

![image-20231027075958876](images/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80(8086).assets/image-20231027075958876.png)



### 数据总线

CPU通过数据总线与内存或其他部件传递数据，总线宽度决定了传输速度。8根数据总线一次性可以传递8位二进制数据（1字节），也就是CPU数据宽度为8。

假设有89D8 H数据需要传输，对于数据宽度为16的CPU来说，一次性可以传递全部数据。对于数据宽度为8的CPU来说，需要两次才能传递全部数据，第一次传递D8 H，第二次传递89H。

![image-20231027081804741](images/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80(8086).assets/image-20231027081804741.png)

![image-20231027081834545](images/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80(8086).assets/image-20231027081834545.png)



### 控制总线

CPU通过控制总线来控制外部器件。这里的控制是个总称，控制总线是一些不同控制线的集合。有多少根控制线，就意味着CPU提供了对外部器件的多少种控制。

内存读或写命令，由几根控制线综合发出的，一根“读信号输出”的控制线负责传送读信号，向该控制线输出低电平表示要读取数据;一根“写信号输出”的控制线则传送写信号。

# 各类存储器芯片

一台PC机上有多个存储器芯片，从物理上看是独立的、不同的器件。从属性上分为RAM和ROM，从功能和连接上分为以下几种：

- 随机存储器

    用于存放供CPU使用的绝大部分程序和数据，主随机存储器一般由两个位置上的RAM组成，装在主板上的RAM和插在扩展插槽上的RAM。

- 装有BIOS(Basic Input/Output System，基本输入/输出系统)的ROM

    在主板和某些接口卡上插有存储相应BIOS的ROM。主板上的ROM; 显卡上的ROM; 网卡上的ROM。

- 接口卡上的RAM（如：显卡上的RAM<显存>）

![image-20231027082942904](images/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80(8086).assets/image-20231027082942904.png)

# 内存地址空间

上述存储器，在物理上是独立的器件，但是在以下两点上相同。

- 都和CPU总线相连。
- CPU对他们读或写的时候都通过控制线发出内存读写命令。

CPU在操控它们的时候，把它们都当作内存来对待，把它们总的看作一个由若干存储单元组成的逻辑存储器，这个逻辑存储器就是我们所说的内存地址空间。

![image-20231027084330889](images/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80(8086).assets/image-20231027084330889.png)

所有的物理存储器被看作一个由若干存储单元组成的逻辑存储器，每个物理存储器在这个逻辑存储器中占有一个地址段，即一段地址空间。CPU在这段地址空间中读写数据，实际上就是在相对应的物理存储器中读写数据。

![image-20231027084602585](images/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80(8086).assets/image-20231027084602585.png)

从地址0~9FFFF的内存单元中读取数据，实际上就是在读取主随机存储器中的数据;向地址A0000~ BFFFF的内存单元中写数据，就是向显存中写入数据，我们向地址C0000~FFFFF 的内存单元中写入数据的操作是无效的，因为这等于改写只读存储器中的内容。

# 寄存器

## 通用寄存器

8086CPU的所有寄存器都是16位的，可以存放两个字节。**AX、BX、CX、DX**这4个寄存器通常用来存放一般性的数据，被称为通用寄存器。**一个n位的寄存器表示的最大数据为2的n次方。**

![image-20231027084947904](images/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80(8086).assets/image-20231027084947904.png)

8086CPU的上一代CPU中的寄存器都是8位的，为了保证兼容，使原来基于上代CPU编写的程序稍加修改就可以运行在8086之上，8086CPU的AX、BX、CX、DX这4个寄存器都可分为两个可独立使用的8位寄存器来用。

- AX可分为AH和AL
- BX可分为BH和BL
- CX可分为CH和CL
- DX可分为DH和DL

![image-20231027085404755](images/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80(8086).assets/image-20231027085404755.png)

## 字在寄存器中的存储

- 字节:记为byte，一个字节由8个bit组成，可以存在8位寄存器中。
- 字:记为word, 一个字由两个字节组成，这两个字节分别称为这个字的高位字节和低位字节。

一个字可以存在一个 16 位寄存器（AH）中，这个字的高位字节和低位字节，存储在高8位寄存器（AH）和低8位寄存器（AL）中。

![image-20231027090006146](images/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80(8086).assets/image-20231027090006146.png)

## 几条汇编指令

![image-20231027090723206](images/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80(8086).assets/image-20231027090723206.png)



## 物理地址

每个内存单元都有唯一的一个地址，CPU要访问内存单元时，要给出内存单元的地址，我们称这个地址为物理地址。



## 16位的CPU结构

8086CPU的上一代CPU是8位机，而8086CPU是16位机，也就是说它是16位结构的CPU。16位结构、16位机、16位字长这几种说法的含义相同，一个CPU具有下面几方面的结构特性。

- 运算器一次最多可以处理16位的数据。
- 寄存器的最大宽度为16位。
- 寄存器和运算器之间的通路为16位。

8086是16位结构的CPU,这也就是说，在8086内部，能够一次性处理、传输、暂时存储的信息的最大长度是16位的。内存单元的地址在送上地址总线之前，必须在CPU中处理、传输、暂时存放，对于16位CPU，能一次性处理、传输、暂时存储16位的地址。

PS:16位的CPU一次性只能进行16位的寻址，也就是CPU寻址的物理地址范围位0 - （2的n次方减1）



## 段地址

8086CPU有20位地址总线，可以传送20位地址，达到1MB寻址能力。8086CPU 又是16位结构，CPU的内部结构来看，如果将地址从内部简单地发出，那么它只能送出16 位的地址，表现出的寻址能力只有64KB。

8086CPU采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址。

![image-20231027115005945](images/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80(8086).assets/image-20231027115005945.png)



## 段地址×16+偏移地址=物理地址

1. CPU中的相关部件提供两个16位的地址，一个称为段地址，另一个称为偏移地址;
2. 段地址和偏移地址通过内部总线送入一个称为地址加法器的部件;
3. 地址加法器将两个16位地址合成为一个20位的物理地址;
4. 地址加法器通过内部总线将20位物理地址送入输入输出控制电路;
5. 输入输出控制电路将20位物理地址送上地址总线;
6. 20位物理地址被地址总线传送到存储器。

![image-20231027115235792](images/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80(8086).assets/image-20231027115235792.png)



## 地址偏移的本质含义

比如说，学校、体育馆、图书馆同在一条笔直的单行路上， 学校位于路的起点(从路的起点到学校距离是0米)。

![image-20231027115337664](images/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80(8086).assets/image-20231027115337664.png)

你要去图书馆，问我那里的地址，我可以用两种方式告诉你图书馆的地址:

1. 从学校走2826m到图书馆。这2826m可以认为是图书馆的物理地址。
2. 从学校走2000m到体育馆，从体育馆再走826m到图书馆。第一个距离2000m,是相对于起点的基础地址，第二个距离826m是相对于基础地址的偏移地址(以基础地址为起点的地址)。

第一种方式是直接给出物理地址2826m，而第二种方式是用基础地址和偏移地址相加来得到物理地址的。

第二个比喻进一步说明“**段地址x16+偏移地址=物理地址**”的思想。

我们为上面的例子加一些限制条件，比如，只能通过纸条来互相通信，你问我图书馆的地址我只能将它写在纸上告诉你。显然，我必须有一张可以容纳4位数据的纸条，才能写下2826这个数据。

![image-20231027190447974](images/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80(8086).assets/image-20231027190447974.png)

可不巧的是，我没有能容纳4位数据的纸条，仅有两张可以容纳3位数据的纸条。这样我只能以这种方式告诉你2826这个数据。

在第一张纸上写上200(段地址)，在第二张纸上写上826(偏移地址)。假设我们事前对这种情况又有过相关的约定，你得到这两张纸后，做这样的运算: 200(段地址)x10+826(偏移地址)=2826(物理地址)。

![image-20231027190552586](images/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80(8086).assets/image-20231027190552586.png)

## 段地址

其实，内存并没有分段，段的划分来自于CPU，由于8086CPU用“基础地址(段地址x 16)+偏移地址=物理地址”的方式给出内存单元的物理地址，使得我们可以用分段的方式来管理内存。我们可以认为:地址10000H~ 100FFH的内存单元组成一个段，该段的起始地址(基础地址)为10000H， 段地址为1000H， 大小为100H; 

![image-20231027214109238](images/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80(8086).assets/image-20231027214109238.png)

段地址x16必然是16的倍数，所以一个段的起始地址也一定是16的倍数，偏移地址为16位，16位地址的寻址能力为64KB，所以一个段的长度最大为64KB。

tips:给出段地址，根据偏移地址，求出最小的物理地址 和 最大的物理地址。物理地址 × 16 + 0 H 和 物理地址 × 16 + FFFF H。



给出物理地址，求最小段地址 和 最大段地址。 

最小段地址 物理地址 - FFFF H ，如果结果低八位为0，则段地址为物理地址 右移8位 右移4位    就是最小段地址。

如果不为0，则右移8位  在加1 在左移四位 就是最小段地址

最大段地址   左移8位 右移4位



## 段寄存器 与 CS 和 IP

### 四个段寄存器

8086CPU在访问内存时要由段存储器提供内存单元的段地址和偏移地址，送入地址加法器合成物理地址。8086的段寄存器有四个：CS、DS、SS、ES。



### CS 和 IP

CS是代码段寄存器，IP是指令指针寄存器。8086CPU中，任意时刻，设CS中的内容为M，IP的内容N，CPU将从M×16+N开始读取一条指令并执行。

![image-20231028091112267](images/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80(8086).assets/image-20231028091112267.png)

1. CPU将CS和IP送入地址加法器
2. 地址加法器将段地址和偏移地址合成物理地址
3. 地址加法器将物理地址送入输入输出控制电路
4. 输入输出控制电路将物理地址通过20位地址总线送入内存
5. 内存将物理地址设为起始地址读取一条指令通过数据总线送入输入输出控制电路
6. 输入输出控制电路将指令送入指令缓冲器
7. 执行控制器从指令缓冲器中读取一条指令并执行
8. 读取一条指令后IP的值自动增加，让CPU可以读取下一条指令，当前读入的指令长度位n字节，IP的值增加n字节。



一条指令通常由前缀（Prefix）、操作码（Opcode）和操作数（Operand）三部分组成，

1. **前缀（Prefix）**：前缀是可选的，它可以改变指令的行为。例如，有些前缀可以改变地址或数据的大小，有些可以改变指令的执行方式。例如，`66h`是一个操作数大小前缀，当它出现在指令前时，会将32位操作数变为16位。
2. **操作码（Opcode）**：操作码是指令的核心，它定义了要执行的操作。例如，`MOV`、`ADD`、`SUB`等都有各自的操作码。
3. **操作数（Operand）**：操作数是指令要操作的对象，可以是寄存器、内存地址或立即数。



举个例子，假设我们有一条指令`66 05 78 56`：

- `66h`是前缀，表示接下来的指令操作数大小为16位。
- `05h`是操作码，表示这是一个加法指令。
- `7856h`是操作数，表示要加的数是`7856h`。

所以这条指令的意思就是将AX寄存器的值加上`7856h`。

`66 05 78 56`这条指令中并没有明确表示操作的对象是AX寄存器。这是因为在x86指令集中，某些指令的操作对象是隐含的。例如，`05`是一个加法指令的操作码，它表示将一个立即数加到AX寄存器（或者EAX寄存器，取决于是否有操作数大小前缀）。所以在这条指令中，操作对象AX寄存器是由操作码`05`隐含的。



### 确定指令长度（所占字节数）

CPU通过预取、预分析和解码三个阶段，**根据操作码、前缀和操作数的信息，确定指令的长度**。具体来说，预取阶段读取字节序列，预分析阶段处理可能存在的前缀并设置状态，解码阶段则根据操作码查表确定指令长度。



### 8086CPU启动

8086CPU开始工作时，CS被设为FFFF H，IP被设为0000 H，CPU启动后从FFFF0 H读取第一条指令并执行。FFFF0 H单元中的指令是CPU执行的第一条指令。



### 区分信息和指令

在村内中，指令和数据没有任何区别，都是二进制信息。CPU将CS:IP指向的内存单元中的内容看作指令，因为，在任何时候，CPU将CS、IP中的内容当作指令的段地址和扁移地址，用它们合成指令的物理地址，到内存中读取指令码，执行。



## jmp指令

`jmp 段地址:偏移地址`

将CS设为段地址处所使用的值，将IP设为便宜地址处所使用的值。

```
jmp 68C3:009E
CS = 68C3
IP = 009E

注:以下两条命令不存在，便于理解
mov cs,68C3
mov ip,009e
```

`jmp 某一合法寄存器`

将IP的值设为指定的某一合法寄存器中的值

```
IP = 00EC
AX = 56A8
jmp ax;
IP = 56A8
AX = 56A8

注:以下两条命令不存在
mov ip,ax
```



## DEBUG的使用

### R

查看、改变CPU寄存器的内容

![image-20231028115122099](images/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80(8086).assets/image-20231028115122099.png)

左下角是CS:IP 内存中机器码 对应的汇编语言

```
r cs   修改寄存器cs的内容
cs:073F
cs:0000

rs ip 修改寄存器ip的内容
ip:0003
ip:0000

rs ax 修改寄存器ax的内容
ax:57EC
ax:0001
```

### D

查看内存中的内容

`d 段地址:偏移地址`

从指定的地址开始查看128字节的内容

![image-20231028124428846](images/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80(8086).assets/image-20231028124428846.png)



`d [段地址]:[偏移地址(起始)] [偏移地址(结束)]`

![image-20231028124537451](images/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80(8086).assets/image-20231028124537451.png)

### E

改写内存单元中的内容

`e 段地址:偏移地址 [4位] [4位] [4位] [4位] [4位] [4位]`

![image-20231028124903965](images/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80(8086).assets/image-20231028124903965.png)

`e 段地址:偏移地址 [8位] [8位] [8位] [8位] [8位] [8位] [8位]`

![image-20231028125034844](images/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80(8086).assets/image-20231028125034844.png)



`e 段地址:偏移地址`交互式

11是原始数据，01是覆盖掉原始数据的新数据，按空格修改下字节数据，按enter表示结束

注：按下空格后就会立即覆盖掉，如果留空直接按空格则不会进行任何操作

![image-20231028125210805](images/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80(8086).assets/image-20231028125210805.png)

### A

`a 段地址:偏移地址`以汇编语言向指定的内存写入指令（自动转换为机器语言）

使用A命令写入汇编指令时，在给出的起始地址后直接按Enter键表示操作结束。

![image-20231028125735370](images/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80(8086).assets/image-20231028125735370.png)

### U

`u 段地址:偏移地址`将内存中的机器语言翻译成汇编语言

![image-20231028125933108](images/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80(8086).assets/image-20231028125933108.png)

`u [段地址]:[偏移地址(起始)] [偏移地址(结束)]`将指定内存范围的机器码用汇编展示

![image-20231028130028747](images/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80(8086).assets/image-20231028130028747.png)

### T

`t`执行一条指令

![image-20231028130420769](images/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80(8086).assets/image-20231028130420769.png)



# 寄存器(内存访问)

## 字存储

高八位：指的是一个字中的高的八位二进制。

高位字节：指的是寄存器中的高的八位二进制。

高内存单元：指的是两个内存单元中，物理地址大的那一个内存单元。

在CPU中16位的寄存器来存储一个字，高8位存放高位字节，低8位存放在低位字节。在内存中，一个内存单元是一个字节，所以如果需要在内存单元中存放一个字，则需要两个字节，内存中高内存单元储高位字节，低内存单元存储低位字节。



如：`204E`是一个字，则寄存器的高八位存储`20`，第八位存储`4E`。

![image-20231028143658381](images/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80(8086).assets/image-20231028143658381.png)

我们用0、1两个内存单元存放数据4E20H。0、1两个内存单元用来存储一个字。对于这个字单元来说，0号单元是低地址单元，1号单元是高地址单元，低位字节（20）存放在0号单元中，高位字节（4E）存放在1号单元中。

假如，我们将1、2两个内存单元看作一个字单元，那么这个字单元的地址就是1，字单元的数据就是124EH



## DS和[address]

在读写内存单元时，必须给出这个内存单元的地址，8086CPU中，内存地址由段地址和偏移地址组成，由一个DS段寄存器通常用来存放要访问数据的段地址，而偏移地址则在访问时给出。



不能直接将1000H存放如ds中，必须线存放到通用寄存器中，再由通用寄存器存放到ds段寄存器中。

`mov bx,[0]`指的是将从[ds]:[0]（1000:0000）中读取16位的数据（因为bx寄存器可以存放16位数据）到bx寄存器中。

```
mov ax,1000H
mov ds,ax
mov bx,[0]
```

为什么8086CPU不支持将数据直接送入段寄存器的操作?这属于8086CPU硬件设计的问题，我们只要知道这一点就行了。



## mov、add、sub可操作对象

目前我们已知的操作对象有数据（8C7EH）、寄存器、段寄存器、内存。

以下列举出常用的合法的和不合法的操作

```
mov ax,07EFH 寄存器，数据 【合法】
mov ax,bx 寄存器，寄存器 【合法】
mov ds,bx 段寄存器，寄存器 【合法】
mov [0],ds 内存，段寄存器 【合法】
mov [0],bx 内存，寄存器 【合法】
mov ds,6FC8H 段寄存器，数据 【非法】
mov ds,[0] 段寄存器，内存 【合法】
mov [0],[1] 内存,内存  【非法】
```



## 数据段

在编程时，可以将一组长度为N（N<=64KB）、地址连续、起始地址为16倍数的内存单元组成一个数据段，专门用于存放数据。

例如：10010 ~ 10019 这段内存是一个数据段，它的段地址为1001，长度为10字节。

访问数据段，将段地址存放在ds中，示例（将数据段的前三个内存单元相加求和）

![image-20231028150357281](images/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80(8086).assets/image-20231028150357281.png)





## 栈 push and pop

栈有两个基本的操作：入栈和出栈。入栈就是将一个新的元素放到栈顶，出栈就是从栈顶取出一个元素。栈顶的元素总是最后入栈，需要出栈时，又最先被从栈中取出栈的这种操作规则被称为:LIFO(LastInFirst Out，后进先出)。



长度为N(N≤64KB)的一组地址连续、起始地址为16 的倍数的内存单元，当作栈空间来用，从而定义了一个栈段。

操作的对象可以是内存，也可以是寄存器



1. 8086CPU提供了栈操作机制，方案如下。

    在SS、SP中存放栈项的段地址和偏移地址;

    提供入栈和出栈指令，它们根据SS:SP指示的地址，按照栈的方式访问内存单元。

2. push指令的执行步骤:

    ①SP=SP -2; 

    ②向SS:SP指向的字单元中送入数据。

3. pop指令的执行步骤:

    ①从SS:SP指向的字单元中读取数据;

    ②SP= SP+2。

4. 任意时刻，SS:SP指向栈项元素。

5. 8086CPU 只记录栈顶，栈空间的大小我们要自己管理。

6. 用栈来暂存以后需要恢复的寄存器的内容时，寄存器出栈的顺序要和入栈的顺序相反。

7. push、pop 实质上是一种内存传送指令，注意它们的灵活应用。



# 汇编程序

一段简单的汇编程序

```assembly
assume cs:codesg

codesg segment

	mov ax,0123H
	mov bx,0456H
	add ax,bx
	add ax,ax
	
	mov ax,4c00H
	int 21H
	
codesg ends

end
```

## segment and ends

**segment 和 ends 组成一个代码段**，前面的**codesg**是代码段的标志，表示这段代码的名称叫做**codesg**，**segment**标志的代码段的开始，**ends**标志的代码段的结束



## assume

这条伪指令的含义为“假设”。它假设某一段寄存器和程序中的某一个用`segment.. .ends`定义的段相关联。通过assume说明这种关联，在需要的情况下，编译程序可以将段寄存器和某一个具体的段相联系。assume 并不是一条非要深入理解不可的伪指令，以后我们编程时，记着用assume将有特定用途的段和相关的段寄存器关联起来即可。

`codesg segment ... codesg ends` 定义了一个名为**codseg**的段，在这个段中存放代码，所以这个段是一个代码段。在程序的开头，用`assume cs:codesg`将用作代码段的段**codesg**和CPU中的**段寄存器cs**联系起来。



## end

end是一个汇编程序的结束标记，编译器在编译汇编程序的过程中，如果碰到了伪指令end，就结束对源程序的编译。汇编需要在结尾处加上伪指令end。否则，编译器在编译程序时，无法知道程序在何处结束。



## 程序的返回

在DOS单任务操作系统中。

1. 一个程序P2在可执行文件中，则必须有一个正在运行的程序P1。
2. 将P2从可执行文件中加载入内存后，将CPU的控制权交给P2。
3. P2才能得以运行，P2开始运行后，P1暂停运行。
4. 而当P2运行完毕后，应该将CPU的控制权交还给使它得以运行的程序P1，此后，P1继续运行。



汇编程序中的两条代码，在目前阶段，我们不必去理解int21H指令的含义，和为什么要在这条指令的前面加上指令`mov ax,4c00H`。我们只要知道，在程序的末尾使用这两条指令就可以实现程序返回。

```assembly
mov ax,4c00H
int 21H
```



## from source code to executable program

### 1.edit source code

使用文本编辑器编写汇编语言的源代码

![image-20231029104033422](images/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80(8086).assets/image-20231029104033422.png)

![image-20231029104126260](images/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80(8086).assets/image-20231029104126260.png)



### 2.complie

完成对源程序的编辑后，得到一个源程序文件t1.asm。可以对其进行编译，生成包含机器代码的目标文件。

![image-20231029104306396](images/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80(8086).assets/image-20231029104306396.png)



### 3.link

在对源程序进行编译得到目标文件后，我们需要对目标文件进行连接，从而得到可执行文件。接续上一节的过程，我们已经对t1.asm进行编译得到t1.obj，现在再将t1.obj连接为t1.exe

![image-20231029104445763](images/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80(8086).assets/image-20231029104445763.png)



## Debug调试程序

可以用Debug来跟踪一个程序的运行过程，这通常是必须要做的工作。

![image-20231029104620795](images/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80(8086).assets/image-20231029104620795.png)



## Dos system executable program loading process

DOS系统可执行程序加载过程

1. 程序加载后，ds中存放着程序所在内存区的段地址，这个内存区的偏移地址为0，则程序所在的内存区的地址为ds:0;
2. 这个内存区的前256个字节中存放的是PSP，DOS用来和程序进行通信。从256字节处向后的空间存放的是程序。



找到一段起始地址为SA:0000的内存地址，这段内存地址的前256（SA:0000 ~ SA:0100 或 SA:0 ~ SA+10H:0）字节存放POP。从第257字节（SA+10H:0000 或 SA:0100）开始存放程序代码。



![image-20231029105110602](images/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80(8086).assets/image-20231029105110602.png)



## [bs] command and loop command

### [bx]

用[0]表示一个内存单元时，0表示单元的偏移地址，段地址默认在ds中.
[bx]同样也表示一个内存单元，它的偏移地址在bx中，比如下面的指令:
`mov ax, [bx]`
将一个内存单元的内容送入ax，这个内存单元的长度为2字节(字单元)，存放一个字，偏移地址在bx中，段地址在ds中。



### loop

loop指令的格式是: loop 标号，CPU执行loop 指令的时候，要进行两步操作

1. (cx)=(cx)-1;
2. 判断cx中的值，不为零则转至标号处执行程序，如果为零则向下执行。

从上面的描述中，可以看到，cx 中的值影响着loop指令的执行结果。通常(注意，我们说的是通常)我们用loop指令来实现循环功能，cx 中存放循环次数。

用cx和loop指令相配合实现循环功能的程序框架如下。

```
	mov cx, 循环次数
S:
	循环执行的程序段
	loop s
```



## Debug g and p

### g command

`g [偏移地址]`一次性执行多条语句，直到到达指定地址

![image-20231029134016604](images/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80(8086).assets/image-20231029134016604.png)

### p command

执行完毕当前的loop循环，类似于C语言中的break语句



## Debug and masm different

Debug

`mov ax, [0]`

表示将ds:0 处的数据送入ax中。

汇编源程序

`mov ax,[0]`

被编译器当作指令“`mov ax,0`”处理。



## 段前缀

指令“`mov ax,[bx]`” 中，内存单元的偏移地址由bx给出，而段地址默认在ds中。可以在访问内存单元的指令中，显式地给出内存单元的段地址所在的段寄存器。

```
mov ax,ds:[bx]
mov ax,cs:[bx]
mov ax,ss:[bx]
mov ax,es:[bx]
```



# 包含多个段的程序

## dw and start

```assembly
assume cs:codesg

codesg segment
    
	
	dw 1122h,3344h,5566h,7788h,99AAh,0BBCCh,0DDEEh,0FEEFh
start:
    mov ax,cs:[0]
    mov bx,cs:[2]
	
	mov ax,4c00h
	int 21h
	
codesg ends

end start
```

程序第一行中的“dw”的含义是定义字型数据。dw即“define word”。在这里，使用dw定义了8个字型数据(数据之间以逗号分隔)，它们所占的内存空间的大小为16个字节。



在程序中使用dw定义的数据会在代码段的最前面，如果不进行指定，默认会去“执行”我们代码段中最前面的数据，所以要使用`end start`指出代码段中的第一条指令的位置。



在程序的第一条指令的前面加上了一个标号start，而这个标号在伪指令end的后面出现。end 除了通知编译器程序结束外，还可以通知编译器程序的入口在什么地方。



```assembly
assume cs:codesg

codesg segment
    
	;数据
	
start:
    
    ;代码

codesg ends

end start
```



## 将数据、代码、栈放入不同的段

1. 把它们放到一个段中使程序显得混乱;
2. 前面程序中处理的数据很少，用到的栈空间也小，加上没有多长的代码，放到一个段里面没有问题。但如果数据、栈和代码需要的空间超过64KB，就不能放在一一个段中(一个段的容量不能大于64KB，是我们在学习中所用的8086 模式的限制，并不是所有的处理器都这样)。



```assembly
assume cs:code,cs:data,ss:stack

data segment
    
    dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h

data ends

stack segment

    dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0

stack ends

code segment

start:
    mov ax,start
    mov ss,ax
    mov sp,20h

    mov ax,data
    mov ds,ax

    mov bx,0
    
    mov cx,8
    input:
        push [bx]
        add bx,2
    loop input

    output:
        pop [bx]
        add bx,2
    loop output

    mov ax,4c00h
    mov 21h

code ends

end start
```



### 1.定义多个段的方法

这点，我们从程序中可明显地看出，定义一个段的方法和前面所讲的定义代码段的方法没有区别，只是对于不同的段，要有不同的段名。



### 2.对段地址的引用

指令“`mov ax,data`”的含义就是将名称为‘data”的段的段地址送入ax。 一个段中的数据的段地址可由段名代表，偏移地址就要看它在段中的位置了。程序中“data”段中的数据“0abch” 的地址就是: data:6。 要将它送入bx中，就要用如下的代码：

```assembly
mov ax, data
mov ds, ax
mov bx,ds: [6]
```

![image-20231030084239090](images/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80(8086).assets/image-20231030084239090.png)



### 3.段名称

段名称仅在源程序中存在，CPU并不知道它们。

在源程序中用伪指令“`assume cs:code,ds:data,ss:stack`”将cs、ds 和ss分别和code、data、 stack 段相连。assume 是伪指令，是由编译器执行的，也是仅在源程序中存在的信息，CPU并不知道它们。我们不必深究assume 的作用，只要知道需要用它将你定义的具有一定用途的段和相关的寄存器联系起来就可以了。



# 灵活内存定位方法

## and 与 or

```assembly
and al,11011111
;将 al 与 11011111 做 与 运算，再将结果存入al
;al = al & 11011111

or al,00100000
;将 al 与 00100000 做 或 运算，再将结果存入al
;al = al | 00100000
```



### si and di

si 和 di 是两个16位的寄存器，可以用来存放内存的偏移地址，这两个寄存器不能拆分为两个8位寄存器使用



## [bx+常量]

```assembly
mov ax,2000H
mov ds,ax

mov bx,10H
mov dx,[bx+1H]
mov dx,[1H+bx]
mov dx,1H[bx]
mov dx,[bx]1H
mov dx,[1H][bx]
mov dx,[bx+si]
mov dx,si[bx]
mov dx,di[bx]
mov dx,[di][bx]
mov dx,[1H][bx][si]
mov dx,[1H+bx+si]
;mov dx,[bx].1H   这里有点问题
;上面几句语句等价,都是在访问 2000H:10H + 1H 的内存单元中的数据
```



# 处理两个数据的基本问题

## 偏移地址寄存器bx、si、di、bp

这四个寄存器用于存储偏移地址，但是以下两种结合是无效的

```assembly
;无效
mov ds:[bx+bp],ax
mov ds:[si+di],ax

;合法
;bx + si bx + di
;bp + si bp + di
```



## 段寄存器 ds、ss、cs、es

只有这四个寄存器用来指示段地址才有效



## 指定数据长度

```
;byte ptr 数据长度1字节
mov byte ptr ds:[0],22H

;word ptr 数据长度2字节（1字单元）
mov word ptr ds:[0] 2F3CH
```



## div伪指令

div [除数]

如果除数为8位，则被除数从AX中获取，计算结果（商）存放在AL中，余数存放在AH中

如果除数为16位，则被除数的高16位从DX中获取，低16位从AX中获取，计算结果（商）存放在AX中，余数存放在DX中



## dd伪指令

dd是用来定义dword(doubleword,双字)型数据的。占用 2 字单元，4字节



## dup指令

dup是一个操作符，由编译器识别处理的符号。它是和db、dw、dd等数据定义伪指令配合使用的，用来进行数据的重复。

`db 3 dup (0)`

定义了3个字节，它们的值都是0，相当于`db 0,0,0`。

`db 3 dup (0,1,2)`

定义了9个字节，它们是0、1、2、0、1、2、0、1、2，相当于`db 0,1,2,0,1,2,0,1,2`。 

`db 3 dup ('abc', ' ABC')`

定义了18个字节，它们是'abcABCabcABCabcABC'， 相当于`db 'abcABCabcABCabcABC'`。

可见，dup的使用格式如下。

```
db [重复的次数] dup (重复的字节型数据)
dw [复复的次数] dup (重复的字型数据)
dd [重复的次数] dup (重复的双字型数据)
;重复的次数可以使用 0FF8 H 0101010B 等
```



# 转移指令的原理

## offset

操作符offset在汇编语言中是由编译器处理的符号，它的功能是取得**段起始地址**到标号处的偏移地址。

```assembly
assume Cs : codesg

codesg segment
start: 
	mov ax, offset start  ;这条指令在内存中占用三个字节
	;相当于mov ax, 0
s: 
	mov ax, offset S
	;相当于 mov ax, 3
codesg ends

end start

```



## jmp

###　jmp short [标号]

“jmp short标号”的功能为: (IP)=(IP)+8 位位移

1. 8位位移=标号处的地址-jmp指令后的第--个字节的地址
2. short 指明此处的位移为8位位移
3. 8位位移的范围为-128~127，用补码表示
4. 8位位移由编译程序在编译时算出。

![image-20231031093023775](images/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80(8086).assets/image-20231031093023775.png)



### jmp near ptr

“jmp near ptr标号”的功能为: (IP)=(IP)+16 位位移。

1. 16位位移=标号处的地址-jmp指令后的第一个字节的地址
2. near ptr指明此处的位移为16 位位移，进行的是段内近转移
3. 16 位位移的范围为-32768~32767，用补码表示
4. 16位位移由编译程序在编译时算出

ps: jmp near ptr 与 jmp short ptr 都是修改IP地址，都是段内在转移，他们的区别是 short 仅支持 -128 ~ 127 范围的转移，而 near 则支持 -32768 ~ 32767 范围的转移



### jmp far ptr

“jmp far ptr标号”实现的是段间转移，又称为远转移。

(CS)=标号所在段的段地址

(IP)=标号在段中的偏移地址。

far ptr指明了指令用标号的段地址和偏移地址修改CS和IP.

**在emu8086 模拟器 v4.08中貌似有点问题**



### jmp 16位reg

指令格式: jmp 16位reg

功能: (IP)=(16 位reg)



### jmp word ptr

jmp word ptr内存单元地址(段内转移)

```assembly
jmp word ptr ds:[bx]
;等价于
mov ax,ds:[bx]
mov ip,ax
```



### jmp dword ptr

jmp word ptr 内存地址单元(段间转移)

```assembly
jmp dword ptr ds:[bx]
;等价于
mov ax,ds:[bx+0]
mov ip,ax
mov ax,ds:[bx+2]
mov cs,ax
```



## jcxz

jCXZ指令为有条件转移指令，所有的有条件转移指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为: -128~127。

指令格式: jcxz 标号(如果(cx)=0，转移到标号处执行。

```
if((cx)==0) 
	jmp short 标号;
```



## loop

loop指令为循环指令，所有的循环指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为: -128~127。

1. (cx)=(cx)-1
2. 如果(cx)≠0， (IP)=(IP)+8 位位移

我们从loop的功能中可以看出，“loop 标号”的功能相当于:

```
(cx)--;
if((cx)≠0)
	jmp short 标号;
```



## 再回显存

80x25模式显示缓冲区的结构:内存地址空间中，B8000H- BFFFFH共32KB的空间，为80x25彩色字符模式的显示缓冲区。向这个地址空间写入数据，写入的内容将立即出现在显示器上。

在80x25彩色字符模式下，显示器可以显示25行，每行80个字符，每个字符可以有256种属性(背景色、前景色、闪烁、高亮等组合信息)。

在一行中，一个字符占两个字节的存储空间(一个字)，低位字节存储字符的ASCII码，高位字节存储字符的属性。一行共有80个字符，占160个字节。

![image-20231031113455858](images/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80(8086).assets/image-20231031113455858.png)

颜色属性表示方法

![image-20231031113520482](images/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80(8086).assets/image-20231031113520482.png)

```
红底绿字，属性字节为: 01000010B;
红底闪烁绿字，属性字节为: 11000010B;
红底高亮绿字，属性字节为: 01001010B;
黑底白字，属性字节为: 00000111B;
白底蓝字，属性字节为: 01110001B。
```



在一页显示缓冲区中:

- 偏移000~09F对应显示器上的第1行(80个字符占160个字节) ;
- 偏移0A0~13F对应显示器上的第2行;
- 偏移140~1DF对应显示器上的第3行;
- 依此类推，可知，偏移F00~F9F对应显示器上的第25行。



在一行中:

- 00~01单元对应显示器上的第1列;
- 02~03单元对应显示器上的第2列;
- 04~05单元对应显示器上的第3列;
- 依此类推，可知，9E~9F单元对应显示器上的第80列。



# call 和 ret 指令

## ret and reft

ret指令用栈中的数据，修改IP的内容，从而实现近转移。

```assembly
ret
;等价于
pop ip
```

retf指令用栈中的数据，修改CS和IP的内容，从而实现远转移。

```assembly
reft
;等价于
pop ip
pop cs
```



## call

注意：所有的call指令push的ip地址，这个地址不是call指令的所占内存空间的首地址，而是call指令的下一条指令所占内存空间的首地址

```assembly
0005 call 00010;s1
0008 nop
0008 nop
;call 指令 执行后 push 压入栈中的值为 0008 而不是 0005
```





```assembly
0000 mov ax,01h
0003 call 0008;[s1] 
0006 nop
0007 nop
0008 mov ax,00h
```

执行完 `call 0008` 指令后，`ss:sp`中的内容为0006

```assembly
;等价于
push ip;ip的地址为call指令的下一条指令的首地址
jmp near ptr 0008;[s1]
```

ps:两处的0008在编译前的汇编源代码中为s1标号



### call far ptr

段间位移

```assembly
push ip
push cs
jmp far ptr 1000:0008;标号
```



### call 16位reg

段内位移

```assembly
push ip
;mov ax,0010
jmp ax
```



### call word ptr

段内位移

```assembly
push ip
jmp word ptr [内存单元地址]
```





### call dword ptr

段间位移

```assembly
push ip
push cs
jmp dword ptr [内存单元地址]
```



## call 和 ret 配合使用

可以写一个具有一定功能的程序段，我们称其为子程序，在需要的时候，用 call 指令转去执行。call指令转去执行子程序之前，call指令后面的指令的地址将存储在栈中，所以可在子程序的后面使用 ret 指令，用栈中的数据设置IP的值，从而转到call指令后面的代码处继续执行。

```assembly
assume cs:code

code segment

start:
	
	;跳转到sub1
	call sub1
	
sub1:
	
	;
	call sub2
	;sub2返回到此处，继续执行
	
	;...............
	
	;返回到start中的call下一条指令
	ret
	
sub2:
	

	;返回到sub1中的call下一条指令
	ret

code ends

end start
```



## mul指令

mul [乘数];reg或者16为reg

两个相乘的数，要么都是8位，要么都是16位

如果是8位，一个乘数存放在al中，另一个存放在reg或者内存中（mul 后面指定），计算结果存放在AX中

如果是16位，一个乘数存放在ax中，另一个存放在reg或者内存中（mul 后面指定），计算结果高8位存放在DX中，低8位存放在AX中



# 标志寄存器

## ZF标志

相关指令执行后，其结果是否为0，如果为0，则ZF为1，如果不为0，则ZF为0

```
mov ax,1
sub ax,1
;sub ax,1执行后，ax为0，ZF为1

mov ax,2
sub ax,1
;sub ax,1执行后，ax为1，ZF为0
```

注意：在汇编指令中，有些指令是影响寄存器的（如：add、sub、mul、div、inc、or、and），有些指令是不影响寄存器的（如：mov、push、pop）。



## PF标志

它记录相关指令执行后，所有结果中的bit位中1的个数是否为偶数，如果是，则PF为1，如果不是则PF为0.

```
mov al,0
add al,10
;执行add al,10后，al为00001011B，有3个1（奇数），PF为0

mov al,0
add al,12
;执行add al,10后，al为00001100B，有2个1（奇数），PF为1
```



## SF标志

它记录相关指令执行后，其结果是否为负。如果结果为负，sf=1; 如果非负，sf=0。

00000001B，可以看作为无符号数1，或有符号数+1;
10000001B，可以看作为无符号数129，也可以看作有符号数-127。
这也就是说，对于同一个二进制数据，计算机可以将它当作无符号数据来运算，也可以当作有符号数据来运算。

```
mov al, 10000001B
add al, 1
```

结果: (al) = 10000010B。

不管我们如何看待，CPU在执行add等指令的时候，就已经包含了两种含义，也将得到用同一种信息来记录的两种结果。关键在于我们的程序需要哪一种结果。
SF标志，就是CPU对有符号数运算结果的一种记录，它记录数据的正负。在我们将数据当作有符号数来运算的时候，可以通过它来得知结果的正负。如果我们将数据当作无符号数来运算，SF 的值则没有意义，虽然相关的指令影响了它的值。



## CF标志

在进行无符号数运算的时候，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值。

当两个数据相加的时候，有可能产生从最高有效位向更高位的进位。比如，两个8位数据: 98H+98H，将产生进位。由于这个进位值在8位数中无法保存，记录在一个特殊的寄存器的某一位上，8086CPU就用flag的CF位来记录。

```
mov al, 98H
add al, al
;执行后: (al)=30H， CF=1，CF记录了从最高有效位向更高位的进位值

add al,al
;执行后: (al)=60H， CF=0，CF记录了从最高有效位向更高位的进位值
```

而当两个数据做减法的时候，有可能向更高位借位。比如，两个8位数据: 97H - 98H，将产生借位，借位后，相当于计197H - 98H。而flag 的CF位也可以用来记录这个借位值。

```
mov al, 97H
sub al, 98H
;执行后: (al)=FFH， CF=1， CF记录了向更高位的借位值
    sub al,al
;执行后: (al)=0， CF=0，CF记录了向更高位的借位值
```



## OF标志

OF记录了有符号数运算的结果是否发生了溢出。如果发生溢出，OF=1；如果没有，OF=0。

```
mov al, 98
add al, 99
```

add指令执行后: CF=0， OF=1。前面我们讲过，CPU在执行add等指令的时候，就包含了两种含义:无符号数运算和有符号数运算。对于无符号数运算，CPU用CF位来记录是否产生了进位；对于有符号数运算，CPU用OF位来记录是否产生了溢出，当然，还要用SF位来记录结果的符号。对于无符号数运算，98+99没有进位，CF=0; 对于有符号数运算，98+99 发生溢出，OF=1。



## adc指令

adc是带进位加法指令，它利用了CF位上记录的进位值。

```
adc ax,bc
;等价于
add ax,bx
add ax,cf
```



## sbb指令

sbb是带借位减法指令，它利用了CF位上记录的借位值。

```
sbb ax,cx
;等价于
sbb ax,bx
sbb ax,cf
```



## cmp指令

cmp是比较指令，cmp的功能相当于减法指令，只是不保存结果。cmp指令执行后,将对标志寄存器产生影响。

```
mov ax,12
cmp ax,2
;结果：ax为12，cmp不改变ax的值，但是会修改标志寄存器中的值
```



## 条件转移指令

![image-20231110104957027](images/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80(8086).assets/image-20231110104957027.png)





## df标志和串送指令



### df标志设置指令

```
cld指令：将flag寄存器df标志设为0
std指令：将flag寄存器df标志设为1
```



## movsb指令

```
;第一步
;将ds:[si]地址一字节的数据复制到es:[di]
mov ah:ds:[si]
mov es:[di],ah

;第二步骤
;如果df标志为0
inc si 		;add si,1
inc di 		;add di,1

;如果df标志为1
sbb si 		;sub si,1
sbb di 		;sub di,1
```



## movsw指令

```
;第一步
;将ds:[si]地址一字（两字节）的数据复制到es:[di]
mov ax:ds:[si]
mov es:[di],ax

;第二步骤
;如果df标志为0
add si,2
add di,2

;如果df标志为1
dec si,2
dec di,2
```



## ret movsb指令

重复执行 movsb指令，执行一次，cx减1，如果cx为0，则停止执行

```
;等价于
s:
	movsb
loop s
```



## pushf 和 popf

pushf的功能是将标志寄存器的值压栈，而popf 是从栈中弹出数据，送入标志寄存器中。

```
pushf ;等价于push flag
popf  ;等价于pop  flag
```



# 内中断



执行完当前正在执行的指令之后，检测到从CPU外部发送过来的或内部产生的一种特殊信息，并且可以立即对所接收到的信息进行处理。这种特殊的信息，我们可以称其为:中断信息。中断的意思是指，CPU不再接着（刚执行完的指令）向下执行，而是转去处理这个特殊信息。



## 类型码

8086CPU，当CPU内部有下面的情况发生的时候，将产生相应的中断信息。

1. 除法错误，比如，执行div指令产生的除法溢出;
2. 单步执行;
3. 执行into指令;
4. 执行int指令。

中断类型码的数据来标识中断信息的来源。中断类型码为一个字节型数据，可以表示256种中断信息的来源。

上述的4种中断源，在8086CPU中的中断类型码如下：

1. 除法错误: 0
2. 单步执行: 1
3. 执行into指令：4
4. 执行`int` 指令，该指令的格式为`int n`，指令中的n为字节型立即数，是提供给CPU的中断类型码。



## 向量表

CPU用8位的中断类型码通过中断向量表找到相应的中断处理程序的入口地址。中断向量表，就是中断处理程序
入口地址的列表。



中断向量表在内存中保存，其中存放着256个中断源所对应的中断处理程序的入口。

![image-20231110130918078](images/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80(8086).assets/image-20231110130918078.png)

对于8086PC机，中断向量表指定放在内存地址0处。从内存0000:0000到0000:03FF的1024个单元中存放着中断向量表。一个表项存放一个中断向量，也就是一个中断处理程序的入口地址，对于8086CPU，这个入口地址包括段地址和偏移地
址，所以一个表项占两个字，高地址字存放段地址，低地址字存放偏移地址。





## 设置中断向量

假设0号表项的入口地址0:200，写入中断向量表的0号表项中，使其成为0号中断的中断处理程序。

0号表项的地址为0:0， 其中0:0字单元存放偏移地址，0:2 字单元存放段地址。程序如下：

```
mov ax, 0
mov es, ax
mov word ptr es: [0*4] , 200h .
mov word ptr es: [0*4+2],0
```



## 过程

CPU收到中断信息后，要对中断信息进行处理。

1. 首先取得中断类型码
2. 将标志寄存器的值入栈
3. 设置标志寄存器的TF和IF的值为0
4. 将原来的CS和IP的值保存起来
5. 将CS:IP 将指向中断处理程序的入口



简洁的描述中断过程

1. 取得中断类型码N;
2. `pushf`
3. `TF=0，IF=0`
4. `push CS`
5. `push IP`
6. `(IP)=(N*4)， (CS)=QN*4+2)`

在最后一步完成后，CPU开始执行由程序员编写的中断处理程序。



## 中断处理程序和iret指令

CPU随时都可能执行中断处理程序，所以中断处理程序必须一直存储在内存某段空间之中。而中断处理程序的入口地址，即中断向量，必须存储在对应的中断向量表表项中。



中断处理程序的编写方法和子程序的比较相似，下面是常规的步骤：

1. 保存用到的寄存器
2. 处理中断;
3. 恢复用到的寄存器; 
4. 用`iret`指令返回



`iret`指令的功能用汇编语法描述为:、

```
pop IP
pop CS
popf
```



## 单步中断

基本上，CPU在执行完一条指令之后，如果检测到标志寄存器的TF位为1，则产生单步中断，引发中断过程。

单步中断的中断类型码为1，则它所引发的中断过程如下。

1. 取得中断类型码1;
2. 标志寄存器入栈， TF、IF设置为0;
3. CS、IP入栈;
4. `(IP)=(1*4)， (CS)=(1*4+2)`。



如上所述，如果TF=1，则CPU每执行一条指令后，CPU就会产生一次单步中断。CPU为什么要提供这样的功能呢?

Debug如何能让CPU在执行一条指令后，就显示各个寄存器的状态？

CPU在执行程序的时候是从CS:IP指向的某个地址开始，自动向下读取指令执行。也就是说，如果CPU不提供其他功
能的话，就按这种方式工作，只要CPU一加电，它就从预设的地址开始一直执行下去，不可能有任何程序能控制它在执行完一条指令后停止，去做别的事情。

可是，我们在Debug中看到的情况却是，Debug可以控制CPU执行被加载程序中的一条指令，然后让它停下来，显示寄存器的状态。

这里是Debug使用了CPU提供的单步中断功能实现的效果。



## 响应特殊中断的情况

在有些情况下，CPU在执行完当前指令后，即便是发生中断，也不会响应。



在执行完向`ss`寄存器传送数据的指令后，即便是发生中断，CPU也不会响应。这样做的主要原因是SS:SP联合指向栈顶，而对它们的设置应该连续完成。

如果在执行完设置`ss`的指令后，CPU响应中断，引发中断过程，要在栈中压入标志寄存器、CS和IP的值。而`ss`改变，`sp`并未改变，`ss:sp`指向的不是正确的栈顶，将引起错误。

所以CPU在执行完设置ss的指令后，不响应中断。





```
mov ax, 1000h
mov SS, ax
mov sp, 0
```



CPU在`mov ss,ax`指令执行后，CPU根本就不响应任何中断，其中也包括单步中断，所以Debug设置好的用来显示寄存器状态和等待输入命令的中断处理程序根本没有得到执行，所以我们看不到预期的结果。

CPU接着向下执行后面的指令`mov sp,10h`，然后响应单步中断，我们才看到正常的结果。所以在单步调试中就像是CPU一次性执行了两条指令。



# `int` 指令

`int`指令的格式为：`int n`,n为中断类型码，它的功能是引发中断过程。CPU执行`int n`指令，相当于引发一个n号中断类型码的中断过程，执行过程如下。

1. 取中断类型码n
2. 标志寄存器入栈，IF=0， TF=0
3. CS、IP入栈
4. `(IP)=(n*4)， (CS)=(n*4+2)`
5. 从此处转去执行n号中断的中断处理程序



`int n`就是触发一次n号中断码，例如`int 0`和`除法溢出中断`是一样的。



## BIOD 和 DOS 提供中断程序

在系统板的ROM中存放着一套程序，称为BIOS(基本输入输出系统)，BIOS 中主要包含以下几部分内容。

1. 硬件系统的检测和初始化程序;
2. 外部中断(第15章中进行讲解)和内部中断的中断例程;
3. 用于对硬件设备进行I/O操作的中断例程;
4. 其他和硬件系统相关的中断例程。



- 操作系统DOS也提供了中断例程，从操作系统的角度来看，DOS的中断例程就是操作系统向程序员提供的编程资源。
- BIOS和DOS在所提供的中断例程中包含了许多子程序，这些子程序实现了程序员在编程的时候经常需要用到的功能。
- 程序员在编程的时候，可以用`int`指令直接调用BIOS和DOS提供的中断例程，来完成某些工作。
- 与硬件设备相关的DOS中断例程中，一般都调用了BIOS的中断例程。



## BIOS和DOS中断例程的安装过程

开机后，CPU一加电，初始化(CS)= 0FFFFH，(IP)=0， 自动从FFFF:0 单元开始执行程序。FFFF:0 处有一条转跳指令，CPU执行该指令后，转去执行BIOS中的硬件系统检测和初始化程序。

初始化程序将建立BIOS所支持的中断向量，即将BIOS提供的中断例程的入口地址登记在中断向量表中。注意，对于BIOS所提供的中断例程，只需将入口地址登记在中断向量表中即可，因为它们是固化到ROM中的程序，一直在内存中存在。

硬件系统检测和初始化完成后，调用`int 19h`进行操作系统的引导。从此将计算机交由操作系统控制。

DOS启动后，除完成其他工作外，还将它所提供的中断例程装入内存，并建立相应的中断向量。



## BIOS 中断程序的使用

调用的中断例程中往往包括多个子程序，中断例程内部用传递进来的参数来决定执行哪一个子程序。BIOS和DOS提供的中断例程，都用ah来传递内部子程序的编号。



### 光标位置子程序

下面看一 下`int 10h`中断例程的设置光标位置功能。

```
mov ah, 2;置光标
mov bh, 0;第0页
mov dh, 5;dh中放行号
mov dl,12;dl中放列号
int 10h
```

功能：设置光标位置

参数：`标所在的行号(80*25字符模式下: 0~24)、列号(80*25 字符模式下: 0~79)， 和页号作为参数。`

(bh)=0，(dh)=5， (d1)=12， 设置光标到第0页，第5行，第12列。

(ah)=2表示调用第10h号中断例程的2号子程序。

作用：将光标位置设置为第0页，第5行，第12列。



### 屏幕字符显示子程序

再看一下int10h中断例程的在光标位置显示字符功能。

```
mov ah,9	;在光标位置显示字符
mov al,'a'	;字符
mov bl,7	;颜色属性
mov bh,0	;第0页
mov CX,3	;字符重复个数
int 10h
```

功能：在屏幕上显示字符

参数：所显示的字符，字符的颜色属性、页号、字符重复的个数

作用：在第0页的光标处，显示字符'a'，重复个数为3，颜色属性为"红底高亮闪烁绿色"

![image-20231110151701020](images/%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80(8086).assets/image-20231110151701020.png)



## DOS中断程序使用

int21h中断例程是DOS提供的中断例程，其中包含了DOS提供给程序员在编程时调用的子程序。
我们前面一直使用的是int 21h中断例程的4ch号子程序功能，即程序返回功能，如下:

```
mov ah,4ch	;程序返回
mov al,0	;返回值
int 21h
```

功能：程序返回

参数：返回值

作用：将程序返回到DOS，返回值为0



使用这个功能经常写做

```
mov ax,4c00H
int 21
```



# 端口

各种存储器都和CPU的地址线、数据线、控制线相连。CPU在操控它们的时候，把它们都当作内存来对待，把它们总地看做一个由若干存储单元组成的逻辑存储器，这个逻辑存储器我们称其为内存地址空间。



在PC机系统中，和CPU通过总线相连的芯片除各种存储器外，还有以下3种芯片。

1. 各种接口卡(比如，网卡、显卡).上的接口芯片，它们控制接口卡进行工作
2. 主板上的接口芯片，CPU通过它们对部分外设进行访问
3. 其他芯片，用来存储相关的系统信息，或进行相关的输入输出处理



在这些芯片中，都有一组可以由CPU读写的寄存器。这些寄存器，它们在物理上可能处于不同的芯片中，但是它们在以下两点上相同。

- 都和CPU的总线相连，当然这种连接是通过它们所在的芯片进行的
- CPU对它们进行读或写的时候都通过控制线向它们所在的芯片发出端口读写命令

从CPU的角度将这些寄存器都当作端口，对它们进行统一编址， 从而建立了一个统一的端口地址空间。每一个端口在地址空间中都有一个地址。



CPU可以直接读写以下3个地方的数据。

1. CPU内部的寄存器
2. 内存单元
3. 端口





## 端口读写

CPU通过端口地址来定位端口，通过地址总线来传送。在PC系统中，8086CPU最多可以定位64KB个不同的端口。则端口地址的范围为0~65535。



`in al, 60h`从60h号端口读入一个字节，执行时与总线相关的操作如下。

1. CPU通过地址线将地址信息60h发出
2. CPU通过控制线发出端口读命令，选中端口所在的芯片，并通知它，将要从中读取数据
3. 端口所在的芯片将60h端口中的数据通过数据线送入CPU



在in和out指令中，只能使用ax或al来存放从端口中读入的数据或要发送到端口中的数据。访问8位端口时用al，访问16位端口时用ax。



0~255的端口读写：

```
in al,20h	;从20h端口读入一个字节
out 20h,al	;往20h端口写入一个字节
```



256~65535端口读写，端口号放在dx中:

```
mov dx,3f8h	;将端口号3f8h送入dx
in al,dx	;从3f8h端口读入一个字节
out dx,al	;向3f8h端口写入一个字节
```



## CMOS RAM芯片读写

PC机中，有一个CMOS RAM芯片，一般简称为CMOS。

此芯片的特征如下：

1. 包含一个实时钟和一个有128个存储单元的RAM存储器(早期的计算机为64个字节)。
2. 该芯片靠电池供电，关机后其内部的实时钟仍可正常工作，RAM中的信息不丢失。
3. 128 个字节的RAM中，内部实时钟占用0~0dh单元来保存时间信息，其余大部分单元用于保存系统配置信息，供系统启动时BIOS程序读取。
4. 该芯片内部有两个端口，端口地址为70h和7lh。 CPU通过这两个端口来读写CMOS RAM。
5. 70h 为地址端口，存放要访问的CMOS RAM单元的地址
6. 71h 为数据端口，存放从选定的CMOS RAM单元中读取的数据，或要写入到其中的数据。


CMOS RAM的读写分两步进行，读或写CMOS RAM的2号单元：

```
;读取
mov al,2
out 70h,al
in al,21h

;写入
mov al,2
out 70h,al
mov al,5
out 71h,al
```



## shl 左移指令 和 shr 右移指令

1. 将一个寄存器或内存单元中的数据向左移位
2. 将最后移出的一位写入CF中
3. 最低位用0补充

```
mov al,01001000b
shl al,1
;执行前al:01001000
;执行后al:10010000	CF = 0 （因为执行前最高位为0）
```

如果移动位数大于1，则需要将移动的位数放入cl

```
mov cl,3
mov al,01001000b
sha al,cl
;执行前al:01001000
;执行后al:01000000 CF = 0 （因为左移最后一位出来的为0）（左移前的倒数第三位为0）
```



shr右移指令与左移指令一样，只不过是向右移动，CF存储右移最后出来的一位的值。



# 外中断

有一种中断信息，来自于CPU外部，当CPU外部有需要处理的事情发生的时候，比如说，外设的输入到达，相关芯片将向CPU发出相应的中断信息。CPU在执行完当前指令后，可以检测到发送过来的中断信息，引发中断过程，处理外设的输入。这种中断叫做外中断。



## 可屏蔽外中断

可屏蔽中断是CPU可以不响应的外中断。当CPU检测到可屏蔽中断信息时，如果IF=1，则CPU在执行完当前指令后响应中断，引发中断过程；如果IF=0，则不响应可屏蔽中断。



可屏蔽中断信息来自于CPU外部，中断类型码是通过数据总线送入CPU的。将IF置0的原因就是，在进入中断处理程序后，禁止其他的可屏蔽中断。

当然，如果在中断处理程序中需要处理可屏蔽中断，可以用指令将IF置1。8086CPU提供的设置IF的指令如下：

```
sti ;设置IF = 1
cli ;设置IF = 0
```



## 不可屏蔽外中断

不可屏蔽中断是CPU必须响应的外中断。当CPU检测到不可屏蔽中断信息时，则在执行完当前指令后，立即响应，引发中断过程。

对于8086CPU，不可屏蔽中断的中断类型码固定为2，不需要取中断类型码。不可屏蔽中断的中断过程为：

1. 标志寄存器入栈，IF=0， TF=0
2. CS、IP 入栈
3. (IP)=(8), (CS)=(0AHI)。



几乎所有由外设引发的外中断，都是可屏蔽中断。当外设有需要处理的事件（比如说键盘输入）发生时，**由相关芯片向CPU发出可屏蔽中断信息**。不可屏蔽中断是在系统中有必须处理的紧急情况发生时用来通知CPU的中断信息。



# 直接断定表

直接断定表是一种编程技术，先简单了解一下前置知识



## 描述了单元长度的标号

有一种标号不但表示内存单元的地址，还表示了内存单元的长度，即表示在此标号处的单元，是一个字节单元，还是字单元，还是双字单元。



因为这种标号包含 了对单元长度的描述，所以在指令中，它可以代表一个段中的内存单元。

比如，对于程序中的`b dw 0`:指令:

```
指令:mov ax,b
相当于:mov ax,cs:[8]

指令:mov b,2
相当于:mov word ptr cs:[8],2

指令:inc b
相当于:inc word ptr cs:[8]
```



对于程序中的“`adb 1,2,3,4,5,6,7,8`”:

```
指令:mov al,a[si]
相当于:mov al,cs:0[si]

指令:mov al,a[3]
相当于:mov al,cs:0[3]

指令:mov al,a[bx+si+3]
相当于:mov al,cs:0[bx+si+3]
```



可见，使用这种包含单元长度的标号，可以使我们以简洁的形式访问内存中的数据。以后，我们将这种标号称为数据标号，它标记了存储数据的单元的地址和长度。它不同于仅仅表示地址的地址标号。


## 将标号当作数据

```
data segment
	a db 1,2,3, 4,5,6,7,8
	b dw 0
	c dw a,b
data ends
```



数据标号c处存储的两个字型数据为标号a、b的偏移地址。相当于:

```
data segment
	a db 1,2,3,4,5,6,7,8
	b dw 0
	C dw offset a, offset b
data ends
```



再比如:

```
data segment
	a db 1,2,3,4,5,6,7,8
	b dw 0
	c dd a,b
data ends 
```



数据标号c处存储的两个双字型数据为标号a的偏移地址和段地址、标号b的偏移地址和段地址。相当于:

```
data segment
	a db 1,2,3,4,5,6,7,8
	b dw 0
	c dw offset a,seg a,offset b,seg b
data ends .
```

seg操作符，功能为取得某--标号的段地址。



## 直接断定表

编写子程序，以十六进制的形式在屏幕中间显示给定的字节型数据。

分析：一个字节需要用两个十六进制数码来表示，所以，子程序需要在屏幕上显示两个ASCII 字符。我们当然用“0”、“1”、 “2” 、“3”、“4”、“6”、“7”、、“8”、 “9”、“A”、“B”、“C”、 “D”、 “E”、 “F”这16个字符来显示十六进制数码。

具体做法：建立一张表，表中依次存储字符“0”~“F”，我们可以通过数值0~15直接查找到对应的字符。



程序实现：

```
;用al传送要显示的数据
showbyte: jmp short show
	table db ' 0123456789ABCDEF'	;字符表
	show:
			push bx
			push es
			
			mov ah,al
			shr ah,1
			shr ah,1
			shr ah,1
			shr ah,1
			;右移4位，ah中得到高4位的值

			and al,00001111b
			;al中为低4位的值
			
			mov bl,ah
			mov bh,0
			mov ah,table[bx] 
			;用高4位的值作为相对于table的偏移，取得对应的字符

			mov bx,0b800h
			mov es,bx
			
			mov es:[160*12+40*2],ah
			
			mov bl,al
			mov bh,0
			mov al,table[bx]
			;用低4位的值作为相对于table的偏移，取得对应的字符
			
			mov es: [160*12+40*2+2],al
			pop es
			pop bx
```



