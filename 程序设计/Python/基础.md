# 基础

## 传入参数

`import sys`

读取命令行参数，把脚本名与其他参数转化为字符串列表存到 `sys` 模块的 `argv` 变量里。

该列表最少有一个元素；未给定输入参数时，sys.argv[0] 是空字符串。给定脚本名是 '-' （标准输入）时，sys.argv[0] 是 '-'。

使用 -c command 时，sys.argv[0] 是 '-c'。

如果使用选项 -m module，sys.argv[0] 就是包含目录的模块全名。、

解释器不处理 -c command 或 -m module 之后的选项，而是直接留在 sys.argv 中由命令或模块来处理。





## 编码

Python 源码文件的默认编码是 UTF-8，如果不使用默认编码，则要声明文件的编码。

```python
# -*- coding: encoding -*-
```

encoding 可以是 Python 支持的任意一种 codecs，例如：

```python
# -*- coding: cp1252 -*-
```



如果源码以 UNIX "shebang" 行 开头，编码声明要写在文件的第二行：

```python
#!/usr/bin/env python3
# -*- coding: cp1252 -*-
```



## 数学运算

表达式语法很直观：运算符 +, -, * 和 / 可被用来执行算术运算；圆括号 (()) 可被用来进行分组。

```python
>>> 2 + 2
4
>>> 50 - 5*6
20
```

整数（如，2、4、20 ）的类型是 int

带小数（如，5.0、1.6 ）的类型是 float



除法运算 (/) 总是返回浮点数。 

`//` 运算符返回整数的姐结果。

`%`运算符返回余数。

 `**` 运算符计算乘方。



## 变量

等号（`=`）用于给变量赋值。

```python
>>> width = 200
>>> height = 5 * 9
>>> width * height
900
```



如果变量未定义（即，未赋值），使用该变量会提示错误：

```python
>>> n  # try to access an undefined variable
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'n' is not defined
```



## 文本

用双引号`"`或单引号`'`包裹起来的字符，结果完全相同，称为字符串：

```python
>>> 'spam eggs'  # single quotes
'spam eggs'
>>> "Paris rabbit got your back :)! Yay!"  # double quotes
'Paris rabbit got your back :)! Yay!'
```



### 转义字符

要标示引号本身，我们需要对它进行“转义”，即在前面加一个 `\`，也可以使用不同类型的引号：

```python
>>> 'doesn\'t'  # use \' to escape the single quote...
"doesn't"
>>> "doesn't"  # ...or use double quotes instead
"doesn't"
```



字符串定义和`print()`函数输出字符串，并打印经过转义的特殊字符：

```python
>>> s = 'First line.\nSecond line.'  # \n means newline
>>> s  # without print(), special characters are included in the string
'First line.\nSecond line.'
>>> print(s)  # with print(), special characters are interpreted, so \n produces new line
First line.
Second line.
```



如果不希望前置 \ 的字符转义成特殊字符，可以使用**原始字符串**（不能以奇数个 `\` 字符结束），在引号前添加 r 即可：

```python
>>> print('C:\some\name')  # here \n means newline!
C:\some
ame
>>> print(r'C:\some\name')  # note the r before the quote
C:\some\name
```



三重引号：`"""..."""` 或 `'''...'''`，字符串中将自动包括行结束符，但也可以在换行的地方添加一个 `\` 来避免：

```python
print("""\
Usage: thingy [OPTIONS]
     -h                        Display this usage message
     -H hostname               Hostname to connect to
""")
```

输出如下（请注意开始的换行符没有被包括在内）：

```
Usage: thingy [OPTIONS]
     -h                        Display this usage message
     -H hostname               Hostname to connect to
```





## 字符串拼接

字符串可以用 `+` 合并（粘到一起），也可以用 `*` 重复：

```python
>>> # 3 times 'abc', followed by '123'
>>> 3 * 'abc' + '123'
'abcabcabc123'
```



相邻的两个或多个 **字符串字面值** （引号标注的字符）会自动合并：

```python
>>> 'Py' 'thon'
'Python'
```



拼接分隔开的长字符串时（只能用于两个字面值，不能用于变量或表达式：）：

```python
>>> text = ('Put several strings within parentheses '
        'to have them joined together.')

>>> text
'Put several strings within parentheses to have them joined together.'
```



合并多个变量，或合并变量与字面值，要用 +：

```python
>>> prefix + 'thon'
'Python'
```



## 字符串索引

```
 +---+---+---+---+---+---+
 | P | y | t | h | o | n |
 +---+---+---+---+---+---+
 0   1   2   3   4   5   6
-6  -5  -4  -3  -2  -1
```

字符串支持 索引 （下标访问），第一个字符的索引是 0。

索引还支持负数，用负数索引时，从右边开始计数。

注意，-0 和 0 一样，因此，负数索引从 -1 开始。

```python
>>> str = "python"
>>> str[0]
'p'
>>> str[-0]
'p'
>>> str[1]
'y'
>>> str[-1]
'n'
```



## 字符串切片

切片允许你获取子字符串：

```python
>>> word[0:2]
'py'
>>> word[2:5]
'tho'
```

切片索引的默认值很有用；省略开始索引时，默认值为 0，省略结束索引时，默认为到字符串的结尾：

```python
>>> word[:2]
'py'
>>> word[4:]
'on'
>>> word[-2:]
'on'
```

注意，输出结果包含切片开始，但不包含切片结束。

因此，s[:i] + s[i:] 总是等于 s：

```python
>>> word[:2] + word[2:]
'Python'
>>> word[:4] + word[4:]
'Python'
```



索引越界会报错：

```python
>>> word[42]  # the word only has 6 characters
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: string index out of range
```



切片会自动处理越界索引：

```python
>>> word[4:42]
'on'
>>> word[42:]
''
```



Python 字符串不能修改，是 immutable 的。因此，为字符串中某个索引位置赋值会报错：

```python
>>> word[0] = 'J'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'str' object does not support item assignment
>>> word[2:] = 'py'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'str' object does not support item assignment
```



要生成不同的字符串，应新建一个字符串：

```python
>>> 'J' + word[1:]
'Jython'
>>> word[:2] + 'py'
'Pypy'
```



内置函数 len() 返回字符串的长度：

```python
>>> s = 'supercalifragilisticexpialidocious'
len(s)
34
```



## 列表

Python 支持多种 复合 数据类型，可将不同值组合在一起，列表也支持索引和切片，其内容可以改变。

最常用的 列表 ，是用方括号标注，逗号分隔的一组值，一般情况下，各个元素的类型相同：

```python
>>> squares = [1, 4, 9, 16, 25]
>>> squares
[1, 4, 9, 16, 25]
```



列表还支持合并操作：

```python
>>> squares + [36, 49, 64, 81, 100]
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
```



list.append() 方法，在列表末尾添加新条目：

```python
>>> cubes.append(216)  # add the cube of 6
>>> cubes.append(7 ** 3)  # and the cube of 7
>>> cubes
[1, 8, 27, 64, 125, 216, 343]
```



当你将一个列表赋值给一个变量时，该变量将引用 现有的列表

```python
>>> rgb = ["Red", "Green", "Blue"]
>>> rgba = rgb
>>> id(rgb) == id(rgba)  # they reference the same object
True
>>> rgba.append("Alph")
>>> rgb
["Red", "Green", "Blue", "Alph"]
```



内置函数 len() 也支持列表：

```python
>>> letters = ['a', 'b', 'c', 'd']
>>> len(letters)
4
```



### 嵌套列表

嵌套列表（创建包含其他列表的列表）：

```python
>>> a = [ [1,2,3] , [4,5,6,7] , ['a','b',c] ]
>>> a
[ [1,2,3] , [4,5,6,7] , ['a','b',c] ]

>>> a[1]
[1,2,3]

>>> a[2]
[4,5,6,7]
>>> a[2][0]
4

>>> a[3]
['a','b','c']
```



### 引用

当你将一个列表赋值给一个变量时，该变量将引用 现有的列表。

```python
>>> a = [1,2,3]
>>> b = a
>>> a
[1,2,3]
>>> b[2] = 4
>>> a
[1,2,4]
```



### 浅拷贝

创建一个新的复合对象，并将原始对象中找到的引用插入到新对象中。

```python
>>> a = [ [1,2,3] , [4,5,6]]
>>> b = a
>>> a
[ [1,2,3] , [4,5,6]]

>>> b[0] = [3,2,1]
>>> b
[ [3,2,1] , [4,5,6]]
>>> a
[ [1,2,3] , [4,5,6]]

>>> b[1] = [6,5,4]
>>> b
[ [3,2,1] , [6,5,4]]
>>> a
[ [1,2,3] , [6,5,4]]
```



### 深拷贝

创建一个新的复合对象，然后递归地将在原始对象中找到的对象的副本插入到新对象中。

```python
>>> a = [ [1,2,3] , [4,5,6]]
>>> b = copy.deepcopy(a) #深拷贝，对b进行任何操作都无法影响a
>>> a
[ [1,2,3] , [4,5,6]]

>>> b[0] = [3,2,1]
>>> b
[ [3,2,1] , [4,5,6]]
>>> a
[ [1,2,3] , [4,5,6]]

>>> b[1] = [6,5,4]
>>> b
[ [3,2,1] , [6,5,4]]
>>> a
[ [1,2,3] , [4,5,6]]
```



### 列表详解

`append(x)`

- 功能：在列表末尾添加元素 `x`。
- 示例：`a.append(x)` 相当于 `a[len(a):] = [x]`。



`extend(iterable)`

- 功能：使用可迭代对象 `iterable` 的元素来扩展列表。
- 示例：`a.extend(iterable)` 类似于 `a[len(a):] = iterable`。



 `insert(i, x)`

- 功能：在索引 `i` 处插入元素 `x`。
- 示例：`a.insert(0, x)` 在列表开头插入，`a.insert(len(a), x)` 等同于 `append(x)`。



 `remove(x)`

- 功能：删除列表中第一个值为 `x` 的元素。
- 注意：如果元素不存在，会引发 `ValueError`。



 `pop([i])`

- 功能：移除并返回列表中指定位置（默认为最后一个）的元素。
- 注意：若列表为空或索引越界，会引发 `IndexError`。



 `clear()`

- 功能：清空列表所有元素。
- 示例：等同于 `del a[:]`。



 `index(x[, start[, end]])`

- 功能：返回元素 `x` 第一次出现的索引，可选参数 `start` 和 `end` 限制搜索范围。
- 注意：元素不存在时，引发 `ValueError`。



 `count(x)`

- 功能：返回列表中元素 `x` 的出现次数。



 `sort(*, key=None, reverse=False)`

- 功能：就地对列表进行排序，可选参数 `key` 和 `reverse` 控制排序方式。



 `reverse()`

- 功能：反转列表中元素的顺序。



 `copy()`

- 功能：返回列表的浅复制，等同于 `a[:]`。



#### 注意事项

- 修改列表的方法如 `insert`, `remove`, `sort` 不会返回值，它们直接修改原列表并返回 `None`。
- 不是所有数据类型都可以比较或排序，尝试对无法比较的元素排序会引发错误。
- 排序和比较操作需确保元素间存在明确的比较规则。





### 列表推导式

列表推导式（List Comprehensions）是Python中一种简洁、高效地创建新列表的方法。它允许你在一个表达式中生成新的列表，基于对现有列表或其他可迭代对象的运算和过滤条件。

```python
[expression for item in iterable if condition]
```

- `expression`：是要应用到每个元素上的操作或表达式。
- `item`：是每次循环中的当前元素。
- `iterable`：是一个可迭代对象，如列表、元组、集合、字典或字符串等。
- `if condition`：是可选的部分，用于过滤元素，只有当条件为真时，相应的元素才会被包含在结果列表中。

```python
number = [ x * 2 for x in range(0,10) if x % 2 == 1]

print(number)
```

输出结果：

```
[2, 6, 10, 14, 18]
```



列表推导式的方括号内包含以下内容：一个表达式，后面为一个 `for` 子句，然后，是零个或多个 `for` 或 `if` 子句。结果是由表达式依据 `for` 和 `if` 子句求值计算而得出一个新列表。

```python
number = [ [x,y] for x in range(1,4) for y in range(3,0,-1) if x != y]
print(number)
```

输出结果：

```
[[1, 3], [1, 2], [2, 3], [2, 1], [3, 2], [3, 1]]
```



#### 其他高效方法

```python
vec = [-4, -2, 0, 2, 4]

# 讲列表的所有值乘2
[x*2 for x in vec]
[-8, -4, 0, 4, 8]

# 筛选列表中大于等于0的值
[x for x in vec if x >= 0]
[0, 2, 4]

# 为列表中的所有值，求绝对值
[abs(x) for x in vec]
[4, 2, 0, 2, 4]

# 移除字符串首部和尾部的空格
freshfruit = ['  banana', '  loganberry ', 'passion fruit  ']
[weapon.strip() for weapon in freshfruit]
['banana', 'loganberry', 'passion fruit']

# 生成1-5的数和它的平方
[[x,x**2] for x in range(1,6) ]
[[1, 1], [2, 4], [3, 9], [4, 16], [5, 25]]

# 扁平化一个二维列表（一个列表的列表）vec，将其转换为一个一维列表。
vec = [[1,2,3], [4,5,6], [7,8,9]]
[num for elem in vec for num in elem]
[1, 2, 3, 4, 5, 6, 7, 8, 9]
```



列表推导式可以使用复杂的表达式和嵌套函数：

```python
from math import pi
>>> [str(round(pi, i)) for i in range(1, 6)]
['3.1', '3.14', '3.142', '3.1416', '3.14159']
```





## 嵌套推导

讲一个3×4的列表进行转置行列：

```python
matrix = [
    [1, 2, 3, 4],
    [5, 6, 7, 8],
    [9, 10, 11, 12],
]

list = []

for i in range(4):
    list_row = []
    for row in matrix:
        list_row.append(row[i])
    list.append(list_row)

print(list)
```

也可以用嵌套的列表推导式

```python
matrix = [
	[1,2,3,4],
	[5,6,7,8],
	[9,10,11,12]
]

list = [ [row[i] for row in matrix] for i in range(4)]
    
print(list)
```

实际应用中，最好用内置函数替代复杂的流程语句。

```python
matrix = [
    [1, 2, 3, 4],
    [5, 6, 7, 8],
    [9, 10, 11, 12]
]

a = list(zip(*matrix))
print(a)

# 也可以用相同的方法恢复
print(list(zip(*a)))
```

输出结果：

```python
[(1, 5, 9), (2, 6, 10), (3, 7, 11), (4, 8, 12)]
[(1, 2, 3, 4), (5, 6, 7, 8), (9, 10, 11, 12)]
```



## 元组

元组由多个用逗号隔开的值组成，例如：

```python
>>> t = 12345, 54321, 'hello!'
>>> t[0]
12345
>>> t
(12345, 54321, 'hello!')
```



元组都要由圆括号标注，这样才能正确地解释嵌套元组。

输入时，圆括号可有可无，不过经常是必须的（如果元组是更大的表达式的一部分）

元组可以嵌套：

```python
>>> u = t, (1, 2, 3, 4, 5)
>>> u
((12345, 54321, 'hello!'), (1, 2, 3, 4, 5))
```



不允许为元组中的单个元素赋值：

```python
>>> t[0] = 88888
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
```



当然，可以创建含列表等可变对象的元组:

```python
>>> u = ([1,2,3],[4,5,6])
>>> u
([1, 2, 3], [4, 5, 6])
```



可以改变元组中可变列表中的值：

```python
>>> u[0][1] = 10
>>> u
([1, 10, 3], [4, 5, 6])
```



但是不能改变元组的值：

```python
>>> u[0] = [1,2,3]
Traceback (most recent call last):
  File "C:\xxx\main.py", line 9, in <module>
    u[0] = [1,2,3]
TypeError: 'tuple' object does not support item assignment
```



元组是 immutable （不可变的），一般可包含异质元素序列，通过解包（见本节下文）或索引访问（如果是 namedtuples，可以属性访问）。

列表是 mutable （可变的），列表元素一般为同质类型，可迭代访问。

注：异质类型指的是，不同的类型，例如一个元组中可能包含整数、浮点、字符串；一个列表中只包含整数、浮点、字符串的其中一个。



构造 0 个或 1 个元素的元组比较特殊：

用一对空圆括号就可以创建空元组；

```python
>>> empty = ()
>>> len(empty)
0
```

只有一个元素的元组可以通过在这个元素后添加逗号来构建（圆括号里只有一个值的话不够明确）

```python
>>> singleton = 'hello',
>>> len(singleton)
1
>>> singleton
('hello',)
```

 

语句 `t = 12345, 54321, 'hello!'` 是 元组打包 的例子：值 `12345, 54321` 和 `'hello!'` 一起被打包进元组。

序列解包时，左侧变量与右侧序列元素的数量应相等：

```python
>>> t = 12345,54321,'hello'
>>> t
(12345,54321,'hello!')

>>> x,y,z = t

>>> x
12345

>>> y
54321

>>> z
'hello!'
```



当我们进行多重赋值操作时，实际上底层是在执行两个步骤：

- 首先是将右边的表达式的结果（如果由多个值组成）自动打包成一个元组（或列表等可迭代对象）；
- 元组再被解包，分配给左边的多个变量。

```python
a, b, c = 1, 2, 3
```

1. **元组打包**：右侧的 `1, 2, 3` 是三个单独的值，它们被自动打包成了一个元组 `(1, 2, 3)`。
2. **序列解包**：紧接着，这个元组 `(1, 2, 3)` 被解包，它的三个元素分别对应地赋值给左侧的三个变量 `a`, `b`, `c`。于是，`a` 获得值 `1`，`b` 获得值 `2`，`c` 获得值 `3`。



## 集合

集合是由不重复元素组成的无序容器。基本用法包括成员检测、消除重复元素。集合对象支持合集、交集、差集、对称差分等数学运算。

注意：创建空集合只能用 `set()`，不能用 `{}`，`{}` 创建的是空字典。

```python
>>> basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}
>>> print(basket)                      # 重复项已被删除
{'orange', 'banana', 'pear', 'apple'}
>>> 'orange' in basket                 # 快速测试是否包含某个元素
True
>>> 'crabgrass' in basket
False
```



集合数学运算：

```python
# 定义两个集合，分别包含字符串'abracadabra'和'alacazam'的唯一字符
>>> a = set('abracadabra')
>>> b = set('alacazam')

# 集合'a'中独有的字母
>>> a
{'a', 'r', 'b', 'c', 'd'}

# 差集：存在于集合'a'中但不在集合'b'中的字母
>>> a - b
{'r', 'd', 'b'}

# 并集：存在于集合'a'、'b'中的所有字母，包括重复的
>>> a | b
{'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'}

# 交集：同时出现在集合'a'和'b'中的字母
>>> a & b
{'a', 'c'}

# 对称差：存在于集合'a'或'b'中，但不同时存在于两者的字母
>>> a ^ b
{'r', 'd', 'b', 'm', 'z', 'l'}
```



集合推导式：

```python
>>> a = {x for x in 'abracadabra' if not in 'abc'}
>>> a
{'r', 'd'}
```



## 字典

字典是以 键 进行索引的，键可以是任何不可变类型；字符串和数字总是可以作为键。

如果一个元组只包含字符串、数字或元组则也可以作为键；

如果一个元组直接或间接地包含了任何可变对象，则不能作为键。 列表不能作为键。



可以把字典理解为 键值对 的集合，但字典的键必须是唯一的。花括号 {} 用于创建空字典。另一种初始化字典的方式是，在花括号里输入逗号分隔的键值对，这也是字典的输出方式。

```python
>>> tel = {'jack': 4098, 'sape': 4139}
>>> tel
{'jack': 4098, 'sape': 4139}

>>> test = {}
>>> len(test)
0
```

如果索引一个不存在字典中的键，并进行赋值，则会自动插入一个这样的键：

如果索引使用一个不存在字典中的键，则会报错

```python
>>> tel
{'jack': 4098, 'sape': 4139}

>>> tel['guido'] = 4127
tel
{'jack': 4098, 'sape': 4139, 'guido': 4127}
```

用 `del` 可以删除键值对：

```python
>>> del tel['sape']
>>> tel
{'jack': 4098, 'guido': 4127}
```

对字典执行 `list(d)` 操作，返回该字典中所有键的列表：

```python
>>> list(tel)
['jack', 'guido']
```

在Python3.7之前的版本字典是无序的，如果要按插入次序排列（如需排序，请使用 `sorted(d)`）：

```
tel = {}
```



检查字典里是否存在某个键，使用关键字 in：

```python
>>> tel = {'jack': 4098, 'sape': 4139}
>>> 'jack' in tel
True
>>> 'sape' not in tel
False
```

dict() 构造函数可以直接用键值对序列创建字典：

```python
>>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])
{'sape': 4139, 'guido': 4127, 'jack': 4098}
```

字典推导式可以用任意键值表达式创建字典：

```python
>>> {x: x**2 for x in (2, 4, 6)}
{2: 4, 4: 16, 6: 36}
```



# 控制流

## while

任何非零整数都为真，零为假。

这个条件也可以是字符串或列表类型的值，任何序列都可以：长度非零就为真，空序列则为假。



比较操作符的写法： `<` （小于）、 `>` （大于）、 `==` （等于）、 `<=` （小于等于)、 `>=` （大于等于）及 `!=` （不等于）。



while 循环只要条件（这里是 a < 10）为真就会一直执行。

```python
i = 0
while i < 10:
	print(i)
	i = i + 1
```



## del语句

 `del` 语句也可用于从列表中移除切片或清空整个列表，而不是值从列表中移除条目：

```python
>>> a = [-1, 1, 66.25, 333, 333, 1234.5]
>>> del a[0]
>>> a
[1, 66.25, 333, 333, 1234.5]
>>> del a[2:4]
>>> a
[1, 66.25, 1234.5]
>>> del a[:]
>>> a
[]
```



也可以使用del删除整个变量

```python
 >>> del a
```





## if语句

最让人耳熟能详的语句应当是 if 语句：

```python
if x == 1:
	print("x==1")
else:
	print("x≠1")
```

```python
if x == 1:
	print("x==1")
else:
	if x == 2:
		print("x==2")
	else:
		print("x ≠ 1 & x ≠ 2")
```

关键字 '`elif`' 是 'else if' 的缩写

```python
if x == 1:
	print("x==1")
elif x == 2:
	print("x==2")
else:
	print("x==1 & x==2")
```



## for

Python 的 `for` 语句不迭代算术递增数值（如 Pascal），或是给予用户定义迭代步骤和结束条件的能力。



`for`循环通过`in`关键字来进行迭代。`in`后面的对象通常是一个可迭代对象（如列表、元组、字典、集合或字符串等）。

在每次迭代中，`for`循环都会从可迭代对象中取出一个元素，并将其赋值给在`for`关键字后面定义的变量。

**注意：for使用in进行迭代，不是创建一个对象的副本，而是创建一个引用**

```python
words = ['cat', 'window', 'defenestrate']
for w in words:
    print(w, len(w))
```

```
cat 3
window 6
defenestrate 12
```



如果in的左边有多个变量名，那么Python会尝试将可迭代对象中的元素解包到这些变量中：

```python
users = [['xiaoshae','yes'],['wangwen','no']]

for user,status in users:
    print(user,status)
```



## range函数

内置函数 range() 用于生成等差数列：

```python
for i in range(5):
	print(i)
```

```
0
1
2
3
4
```

生成的序列绝不会包括给定的终止值；

`range(10)` 生成 10 个值——长度为 10 的序列的所有合法索引。



range 可以不从 0 开始，且可以按给定的步长递增（即使是负数步长）：

1. 从5开始到9结束

```python
>>> list(range(5, 10))
[5, 6, 7, 8, 9]
```

2. 从0到9，步长为+3

```python
>>> list(range(0, 10, 3))
[0, 3, 6, 9]
```

3. 从-10到-69，步长-30

```python
>>> list(range(-10, -100, -30))
[-10, -40, -70]
```



要按索引迭代序列，可以组合使用 range() 和 len()：

```python
a = ['Mary', 'had', 'a', 'little', 'lamb']
for i in range(len(a)):
    print(i, a[i])
```

```
0 Mary
1 had
2 a
3 little
4 lamb
```



如果直接打印一个 range 会发生意想不到的事情：

```python
>>> range(10)
range(0, 10)
```

对象只有在被迭代时才一个一个地返回所期望的列表项，称为可迭代对象 iterable，适合作为需要获取一系列值的函数或程序构件的参数：

```python
sum(range(4))  # 0 + 1 + 2 + 3
```

```
6
```



## continue、else、break

for 或 while 循环可以包括 else 子句。

1. for 循环中，else 子句会在循环成功结束最后一次迭代之后执行。
2. while 循环中，它会在循环条件变为假值后执行。

3. 无论哪种循环，如果因为 break 而结束，那么 else 子句就 不会 执行。

4. continue 语句，同样借鉴自 C 语言，以执行循环的下一次迭代来继续。



## pass

pass 语句不执行任何动作。语法上需要一个语句，但程序毋需执行任何动作时，可以使用该语句。

这常用于创建一个最小的类：

```python
>>> class MyEmptyClass:
...     pass
```

用作函数或条件语句体的占位符，让你保持在更抽象的层次进行思考。`pass` 会被默默地忽略：

```python
>>> def initlog(*args):
...     pass   # Remember to implement this!
```



## match

Python 3.10引入了一种新的语法，叫做结构模式匹配（Structural Pattern Matching），也就是我们通常所说的match-case语句

```
match subject:
    case pattern1:
        action1
    case pattern2:
        action2
    ...
    case _:
        default_action
```

1. subject是要匹配的对象
2. pattern是匹配模式
3. action是当模式匹配成功时执行的代码2。



match会按照顺序检查每一个case，并且只会执行第一个匹配成功的case；

一旦找到匹配的case，就会执行相应的代码块，并且跳过后面的所有case；

```python
def http_error(status):
    match status:
        case 400:
            return 'Bad request'
        case 401:
            return 'Unauthorized'
        case 403:
            return 'Forbidden'
        case 404:
            return 'Not found'
        case _:
            return 'Unknown status code'
```



在Python的`match-case`语句中，你可以使用列表（List）作为解包模式。

列表是可变的，需要使用`list()`函数或者方括号`[]`来创建一个新的列表：

```python
point = [1, 2]
match point:
    case [0, y]:
        print(f"Y={y}")
    case [x, 0]:
        print(f"X={x}")
    case [x, y]:
        print(f"X={x}, Y={y}")
    case _:
        raise ValueError("Not a point")
```



## 循环的技巧

当对字典执行循环时，可以使用 items() 方法同时提取键及其对应的值：

```python
>>> knights = {'gallahad': 'the pure', 'robin': 'the brave'}
>>> for k, v in knights.items():
        print(k, v)

gallahad the pure
robin the brave
```



在序列中循环时，用 enumerate() 函数可以同时取出位置索引和对应的值：

```python
>>> for i, v in enumerate(['tic', 'tac', 'toe']):
        print(i, v)

0 tic
1 tac
2 toe
```



同时循环两个或多个序列时，用 zip() 函数可以将其内的元素一一匹配：

```python
>>> questions = ['name', 'quest', 'favorite color']
>>> answers = ['lancelot', 'the holy grail', 'blue']
>>> for q, a in zip(questions, answers):
        print('What is your {0}?  It is {1}.'.format(q, a))

What is your name?  It is lancelot.
What is your quest?  It is the holy grail.
What is your favorite color?  It is blue.
```



为了逆向对序列进行循环，可以求出欲循环的正向序列，然后调用 reversed() 函数：

```python
>>> for i in reversed(range(1, 10, 2)):
        print(i)

9
7
5
3
1
```



按指定顺序循环序列，可以用 sorted() 函数，在不改动原序列的基础上，返回一个重新的序列：

```python
basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']
for i in sorted(basket):
    print(i)

apple
apple
banana
orange
orange
pear
```



使用 set() 去除序列中的重复元素。使用 sorted() 加 set() 则按排序后的顺序，循环遍历序列中的唯一元素：

```python
basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']
for f in sorted(set(basket)):
    print(f)

apple
banana
orange
pear
```



一般来说，在循环中修改列表的内容时，创建新列表比较简单，且安全：

```python
import random

raw_data = [random.randint(1, 100) for i in range(20)]
filtered_data = []

for value in raw_data:
    if value >= 50:
        filtered_data.append(value)

print(raw_data)
print(filtered_data)
```

运行结果：

```
[51, 24, 51, 52, 36, 35, 97, 40, 86, 50, 11, 66, 46, 83, 98, 65, 10, 40, 66, 68]
[51, 51, 52, 97, 86, 50, 66, 83, 98, 65, 66, 68]
```



## 深入条件控制

**基本概念**

- `while`和`if`条件句不仅限于比较操作，还能够利用各种运算符进行逻辑判断。
- **比较运算符**包括`in`, `not in`, `is`, `is not`，适用于成员检测及对象同一性验证。
- 所有比较运算符的优先级相同，但低于数值运算符。
- 支持**链式比较**，如`a < b == c`，检查a小于b同时b等于c。

**运算符详情**

1. **成员检测运算符**

    - `in`: 判断值是否在容器中存在。
    - `not in`: 判断值是否不在容器中。

2. **同一性运算符**

    - `is`: 判断两个对象是否为同一个对象。
    - `is not`: 判断两个对象是否不是同一个对象。

3. **布尔运算符**

    - `and`: 逻辑与，两边均为真时结果为真。
    - `or`: 逻辑或，两边任一为真时结果为真。
    - `not`: 逻辑非，取反操作，真变假，假变真。

    注意：`and`和`or`为短路运算符，即从左到右计算，一旦结果确定则停止后续计算。

4. **优先级**

    - `not` > `and` > `or`（从高到低）

    - 使用括号`()`可改变默认优先级。



**应用与示例**

- **链式比较示例**: `a < b == c`，确保表达式从左至右依次满足。
- **短路逻辑示例**: `A and not B or C` 实际执行为 `((A and (not B)) or C)`，若A为真且B为假，则不会评估C。



注意：Python 与 C 不同，在表达式内部赋值必须显式使用 海象运算符 :=。 这避免了 C 程序中常见的问题：要在表达式中写 == 时，却写成了 =。



## 序列与其他类型比较规则

**序列类型比较**：序列对象（如元组、列表、字符串）间的比较基于字典序。

- 首先比较第一个元素，若不等则决定整体大小；若相等，则继续比较下一个元素，直至序列结束或发现不等元素。
- 若一个序列是另一个序列的前缀，则较短的序列视为较小。
- 字符串比较依据Unicode码位点顺序。



**示例**

- `(1, 2, 3) < (1, 2, 4)`: 第三个元素决定大小。
- `['ABC'] < ['C']`: 单个字符按字典序，'A' < 'C'。
- `'ABC' < 'Pascal' < 'Python'`: 字符逐个比较。
- `(1, 2, 3, 4) < (1, 2, 4)`: 长度不同，较短序列`<`较长序列。
- `(1, 2) < (1, 2, -1)`: 短序列在长序列前。
- `(1, 2, 3) == (1.0, 2.0, 3.0)`: 类型不同但数值相等，视为相等。
- `(1, 2, ('aa', 'ab')) < (1, 2, ('abc', 'a'), 4)`: 深入比较嵌套序列。



**不同类型比较**

- 当比较不同类型的对象时，若双方均定义了比较方法（如数字类型），则可通过这些方法进行比较。
- 例如，`0 == 0.0`，因数字类型间比较基于数值。
- 若无合适的比较方法定义，尝试比较会引发`TypeError`异常。



# 函数

## 定义函数

定义 函数使用关键字 def，后跟函数名与括号内的形参列表。函数语句从下一行开始，并且必须缩进。

```python
def sum(n):
	list = []
	for i in range(n):
		list.append(i)
	return list
```



当一个函数调用另外一个函数时，会为该调用创建一个新的局部符号表。

实参是使用 按值调用 来传递的（其中的 值 始终是对象的 引用 而不是对象的值）。

函数在 执行 时使用函数局部变量符号表，所有函数变量赋值都存在局部符号表中；

引用变量时，首先，在局部符号表里查找变量，然后，是外层函数局部符号表，再是全局符号表，最后是内置名称符号表。

注意：尽管可以引用全局变量和外层函数的变量，但最好不要在函数内直接赋值（除非是 global 语句定义的全局变量，或 nonlocal 语句定义的外层函数变量）。



以使用其他名称指向同一个函数对象，并访问访该函数：

```python
def sum(n):
	list = []
	for i in range(n):
		list.append(i)
	return list

s = sum
print(s(10))
```



没有 return 语句的函数返回值是 None （是一个内置名称）



## 函数默认参数

为参数指定默认值是非常有用的方式。调用函数时，可以使用比定义时更少的参数，例如：

```python
def sum(start,end,step=1,quantity=100):
	list = []
	while start < end and list.len() <= quantity:
		list.append(start)
		start = start + step
	return list
```



调用示例：

1. `sum(1,10)`只提供必须的参数
2. `sum(1,10,2)`，提供必须的参数和**部分**可选参数
3. `sum(1,10,1,5)`，提供所有参数（必须的参数和所有可选的参数）



**重要警告：** 默认值只计算一次。默认值为列表、字典或类实例等可变对象时，会产生与该规则不同的结果。例如，下面的函数会累积后续调用时传递的参数：

```python
def f(a, L=[]):
    L.append(a)
    return L

print(f(1))
print(f(2))
print(f(3))
```

输出结果如下：

```
[1]
[1, 2]
[1, 2, 3]
```



不想在后续调用之间共享默认值时，应以如下方式编写函数：

```python
def f(a, L=None):
    if L is None:
        L = []
    L.append(a)
    return L
```



## 关键词参数

kwarg=value 形式的 关键字参数 也可以用于调用函数。函数示例如下：、

```python
def sum(start,end,step=1,quantity=100):
	list = []
	while start < end and list.len() <= quantity:
		list.append(start)
		start = start + step
	return list
```



该函数接受两个必须参数和两个可选参数，以下是使用关键字参数调用的正确方法：

```python
sum(1,10)
sum(start=1,end=10)

sum(1,10,2)
sum(start=1,end=10,step=2)

sum(1,10,1,5)
sum(start=1,end=10,step=1,quantity=5)

sum(1,10,2)
sum(start=1,end=10,quantity=2)

sum(quantity=2,start=1,end=2,step=1)
```



以下调用函数的方式都无效：

```python
sum()
sum(quantity=2,1,10,2)
sum(1,quantity=2)
sum(1,10,ssttep=1)
sum(1,10,start=1)
```

- 函数调用时，关键字参数必须跟在位置参数后面；
- 所有传递的关键字参数都必须匹配一个函数接受的参数（比如，`ssttep` 不是函数 `sum` 的有效参数）；
- 关键字参数的顺序并不重要；
- 不能对同一个参数多次赋值。





## 特殊参数

默认情况下，参数可以按位置或显式关键字传递给 Python 函数。也可以设定参数项是仅按位置、按位置或关键字，还是仅按关键字传递：

```python
def f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2):
      -----------    ----------     ----------
        |             |                   |
        |           位置或关键字			  |
        |                                 - 仅关键字
         -- 仅限位置
```

函数定义中未使用 `/` 和 `*` 时，参数可以按位置或关键字传递给函数。

- 仅限位置形参应放在 `/` （正斜杠）前。
- 仅限关键字形参应放在 `*` （星号）后。
- 位置和关键字形参位于`/`于`*`之间。



## 额外的参数

函数定义中两种特殊的形参语法：`*name` 和 `**name`，用于处理函数调用时传递的额外参数。

1. `*name`：当在函数定义中使用`*name`（星号后跟一个变量名，如`*args`）时，这个形参会接收一个元组，其中包含了所有未被明确命名的、额外的位置参数。
2. `**name`：而当使用`**name`（两个星号后跟一个变量名，如`**kwargs`）时，这个形参会接收一个字典，该字典包含了所有以关键字形式（形如`key=value`）传递的、但没有在函数定义中明确命名的额外参数。



示例：

```python
def text(end,*args,**kwargs):

    for tmp in args :
        print(tmp,end=end)

    for key,value in kwargs.items() :
        print(key,'=',value,end=end)

text('\n','xiaoshae','wangzhe',type='users',name='Junyi LI',passwd='ITT')
```

输出结果：

```
xiaoshae
wangzhe
type = users
name = Junyi LI
passwd = ITT
```



**注意**：

- `*name`必须出现在`**name`之前
- 一旦使用了`*args`来收集额外的位置参数，之后的所有参数都必须通过关键字传递（也就是成为仅限关键字参数）



## 形参字典与关键字参数冲突

这里有两个参数：`name`是一个位置参数，`**kwds`是一个接收额外关键字参数的形参。

```python
def foo(name, **kwds):
    return 'name' in kwds
```

当通过关键字传递一个与位置参数同名的参数时，就会产生冲突。（python不允许重复传递参数）



`name=2`试图通过关键字参数的形式再次给`name`赋值，与位置参数`name`接收的值1冲突，导致Python抛出`TypeError`，指出`foo()`为参数`name`收到了多个值。

```python
foo(1, **{'name': 2})
```



使用语法`/`，用于明确区分位置参数和关键字参数：

```python
def foo(name, /, **kwds):
    return 'name' in kwds
```

- `name`被定义为仅限位置参数，而后面的`**kwds`继续收集额外的关键字参数；
- `name`只能作为位置参数使用，而`'name'`则直接进入`kwds`字典中。



## 解包

"解包"（unpacking）是指将容器类型（如列表、元组或字典）中的元素展开为单独的变量或函数参数的过程。

- 星号`*`解包序列类型如列表和元组；
- 双星号`**`解包字典。



### 列表或元组解包

当调用一个函数，而它的参数需要独立提供时，如果这些参数存储在一个列表或元组中，你可以使用星号`*`来解包它们。

```python
args = [3, 6]  # 这是一个包含起始值和结束值的列表
for i in range(*args):  # 使用 *args 来解包列表，等效于 range(3, 6)
    print(i)
```



### 字典解包

双星号`**`操作符用于解包字典的**键值对**作为关键字参数传递给函数。

```python
def text(start,end):

    for i in range(start,end):

        print(i)

kwds = {
    'start':0,
    'end':10
}

text(**kwds)
#等价于
text(start=1,end=10)
```



# 模块

Python 把各种定义存入一个文件，在脚本或解释器的交互式实例中使用。这个文件就是 模块 ；模块中的定义可以 导入 到其他模块或 主 模块。

模块是包含 Python 定义和语句的文件。其文件名是模块名加后缀名 `.py` 。在模块内部，通过全局变量 `__name__` 可以获取模块名（即字符串）。



文本编辑器在当前目录下创建 fibo.py 文件：

```python
def fib(n):
    a, b = 0, 1
    while a < n:
        print(a, end=' ')
        a, b = b, a+b
    print()

def fib2(n):
    result = []
    a, b = 0, 1
    while a < n:
        result.append(a)
        a, b = b, a+b
    return result
```



以下命令导入该模块：

```python
import fibo
```

此操作不会直接把 `fibo` 中定义的函数名称添加到当前命名空间，它只是将模块名称 `fibo` 添加到那里。

使用该模块名称你可以访问其中的函数：

```python
>>> fibo.fib(1000)
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987
>>> fibo.fib2(100)
[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
>>> fibo.__name__
'fibo'
```



如果经常使用某个函数，可以把它赋值给局部变量：

```python
>>> fib = fibo.fib
>>> fib(500)
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377
```



模块包含**可执行语句及函数定义**。这些语句用于初始化模块，且**仅在 import 语句 第一次 遇到模块名时执行。**

每个模块都有自己的私有命名空间，它会被用作模块中定义的所有函数的全局命名空间。

模块内使用全局变量而不必担心与用户的全局变量发生意外冲突，可以通过标记法 `modname.itemname` 来访问一个模块的全局变量

模块可以导入其他模块， 如果被放置于一个模块的最高层级，则被导入的模块名称会被添加到该模块的全局命名空间。



将来自某个模块的名称直接导入到导入方模块的命名空间：

```python
>>> from fibo import fib, fib2
>>> fib(500)
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377
```

导入模块内定义的所有名称（**不导入**以下划线（`_`）开头的名称）：

```python
>>> from fibo import *
>>> fib(500)
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377
```



import可以使用`as`关键字在导入时为模块设置别名：

```python
>>> import fibo as fib
>>> fib.fib(500) # 使用fib(fibo)模块中的fib函数
fib.fib(500)
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377
```

from ... import ... 也可以使用这种方法：

```python
>>> from fibo import fib as fibonacci
>>> fibonacci(500)
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377
```



## 以脚本方式执行模块

可以用以下方式运行 Python 模块：

```shell
python fibo.py <arguments>
```

这项操作将执行模块里的代码，但会把 `__name__` 赋值为 `"__main__"`



当Python解释器执行一个脚本文件（.py文件）时，它会将该文件的`__name__`属性设置为`"__main__"`

如果这个文件是被其他模块导入的，那么被导入模块的`__name__`属性将会是该模块的名称。

把下列代码添加到模块末尾：

```python
if __name__ == "__main__":
    import sys
    fib(int(sys.argv[1]))
```



这个文件既能被用作脚本，又能被用作一个可供导入的模块，因为解析命令行参数的那两行代码只有在模块作为“main”文件执行时才会运行：

```shell
$ python fibo.py 50
0 1 1 2 3 5 8 13 21 34
```



## python 模块缓存

编译后的模块存储在`__pycache__`目录下，通过缓存模块的编译版本(.pyc文件)，Python能更快地加载模块。

不同Python版本间的编译文件可共存，`module.version.pyc`，其中`version`对应Python版本，如`spam.cpython-33.pyc`。

Python自动对比源文件与编译文件的修改时间，决定是否重新编译。



直接从命令行加载的模块每次都重新编译，不保存编译结果。

若缺少源模块，Python不会查找缓存。要隐藏源代码，可将`.pyc`文件置于源目录，确保无同名源文件共存。



编译选项：

- `-O`：去除断言，减小文件大小。
- `-OO`：进一步去除`__doc__`字符串，更小但可能影响依赖这些信息的程序。

**性能提示**：.pyc加快的是加载速度，运行时与.py文件性能相同。

**compileall模块**：一键为指定目录下的所有模块生成.pyc文件。





## 包

**包**是组织模块的一种方式，允许创建具有层次结构的模块命名空间。通过使用“带点号模块名”，如 `A.B`，可以访问包 `A` 中的子模块 `B`。包有助于避免模块名冲突，同时支持模块功能的模块化和分类。



### 包的目录结构

一个典型的包结构示例是声音处理包，它包含不同的子包以处理声音文件格式、效果和过滤器：

```
sound/
│   __init__.py         # 初始化包
│
├── formats/           # 文件格式转换子包
│   │   __init__.py
│   ├── wavread.py
│   ├── wavwrite.py
│   └── ...
│
├── effects/          # 声音效果子包
│   │   __init__.py
│   ├── echo.py
│   ├── surround.py
│   └── ...
│
└── filters/          # 过滤器子包
    │   __init__.py
    ├── equalizer.py
    ├── vocoder.py
    └── ...
```



### `__init__.py` 文件

- **作用**：使包含它的目录被视为一个包。
- **内容**：可以为空，也可包含初始化代码或定义 `__all__` 列表来控制 `from package import *` 导入的内容。



### 导入包和子模块

#### 完整导入

```python
import sound.effects.echo
```

- **说明**：这种方式会导入 `sound` 包下的 `effects` 子包中的 `echo` 模块。之后，需要通过全名 `sound.effects.echo` 来访问模块中的内容，比如调用函数时应写为 `sound.effects.echo.echofilter()`。

#### 从包导入子模块

```python
from sound.effects import echo
```

- **说明**：这种方式直接导入 `echo` 子模块到当前命名空间，无需再通过包名访问。调用函数时可直接写为 `echo.echofilter()`。

#### 直接导入函数或变量

```python
from sound.effects.echo import echofilter
```

- **说明**：这是最具体的导入方式，直接将 `echofilter` 函数导入当前命名空间，调用时只需写 `echofilter()` 即可。这种方法使得代码更简洁，但过度使用可能导致命名冲突或代码阅读难度增加。



### **all** 列表

位于包的 `__init__.py` 文件中，它是一个由字符串组成的列表，每个字符串对应一个模块、类、函数或其他可导入项的名称。

```python
# sound/effects/__init__.py
__all__ = ['echo', 'surround']
```



运行 `from package import *` 时，将会导入 `__init__.py` 代码定义的列表 `__all__`中包含的模块。



如果在 `sound/effects/__init__.py` 文件中定义了一个名为 `reverse` 的函数，并尝试使用 `from sound.effects import *`

导致 `reverse` 子模块不会被导入，而是将`__init__.py` 中定义的 `reverse` 函数会被导入到当前命名空间中。



如果没有定义__all__它只是确保包 `sound.effects` 已被导入（可能还会运行 `__init__.py` 中的任何初始化代码），然后再导入包中定义的任何名称。 这包括由 `__init__.py` 定义的任何名称（以及显式加载的子模块）



### 相对导入

- **语法**：使用点号(`.`)来表示当前包或上级包，如 `from . import sibling_module` 或 `from ..parent import module`。
- **限制**：不能在主模块（`__name__ == "__main__"`）中使用相对导入。

### 多目录中的包

- **`__path__` 属性**：可以通过修改包的 `__init__.py` 中的 `__path__` 列表，来扩展模块搜索路径，从而支持跨目录的包结构。
